<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.1//EN">

<book>
<?dbhtml filename="index.html">

<!-- ****************************************************** -->
<!-- Header  -->
<!-- ****************************************************** -->
  <bookinfo>
    <title>Writing an ALSA Driver</title>
    <author>
      <firstname>Takashi</firstname>
      <surname>Iwai</surname>
      <affiliation>
        <address>
          <email>tiwai@suse.de</email>
        </address>
      </affiliation>
     </author>

     <date>Mar. 6, 2004</date>
     <edition>0.3.1</edition>

    <abstract>
      <para>
        This document describes how to write an ALSA (Advanced Linux
        Sound Architecture) driver.
      </para>
    </abstract>

    <legalnotice>
    <para>
    Copyright (c) 2002-2004  Takashi Iwai <email>tiwai@suse.de</email>
    </para>

    <para>
    This document is free; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version. 
    </para>

    <para>
    This document is distributed in the hope that it will be useful,
    but <emphasis>WITHOUT ANY WARRANTY</emphasis>; without even the
    implied warranty of <emphasis>MERCHANTABILITY or FITNESS FOR A
    PARTICULAR PURPOSE</emphasis>. See the GNU General Public License
    for more details.
    </para>

    <para>
    You should have received a copy of the GNU General Public
    License along with this program; if not, write to the Free
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
    MA 02111-1307 USA
    </para>
    </legalnotice>

  </bookinfo>

<!-- ****************************************************** -->
<!-- Preface  -->
<!-- ****************************************************** -->
  <preface id="preface">
    <title>Preface</title>
    <para>
      This document describes how to write an
      <ulink url="http://www.alsa-project.org/"><citetitle>
      ALSA (Advanced Linux Sound Architecture)</citetitle></ulink>
      driver. The document focuses mainly on the PCI soundcard.
      In the case of other device types, the API might
      be different, too. However, at least the ALSA kernel API is
      consistent, and therefore it would be still a bit help for
      writing them.
    </para>

    <para>
    The target of this document is ones who already have enough
    skill of C language and have the basic knowledge of linux
    kernel programming.  This document doesn't explain the general
    topics of linux kernel codes and doesn't cover the detail of
    implementation of each low-level driver.  It describes only how is
    the standard way to write a PCI sound driver on ALSA.
    </para>

    <para>
      If you are already familiar with the older ALSA ver.0.5.x, you
    can check the drivers such as <filename>es1938.c</filename> or
    <filename>maestro3.c</filename> which have also almost the same
    code-base in the ALSA 0.5.x tree, so you can compare the differences.
    </para>

    <para>
      This document is still a draft version. Any feedbacks and
    corrections, please!!
    </para>
  </preface>


<!-- ****************************************************** -->
<!-- File Tree Structure  -->
<!-- ****************************************************** -->
  <chapter id="file-tree">
    <title>File Tree Structure</title>

    <section id="file-tree-general">
      <title>General</title>
      <para>
        The ALSA drivers are provided in the two ways.
      </para>

      <para>
        One is the the trees provided as a tarball or via cvs from the
      ALSA's ftp site, and another is the 2.6 (or later) Linux kernel
      tree. To synchronize both, the ALSA driver tree is split to
      two different trees: alsa-kernel and alsa-driver. The former
      contains purely the source codes for the Linux 2.6 (or later)
      tree. This tree is designed only for compilation on 2.6 or
      later environment. The latter, alsa-driver, contains many subtle
      files for compiling the ALSA driver on the outside of Linux
      kernel like configure script, the wrapper functions for older,
      2.2 and 2.4 kernels, to adapt the latest kernel API,
      and additional drivers which are still in development or in
      tests.  The drivers in alsa-driver tree will be moved to
      alsa-kernel (eventually 2.6 kernel tree) once when they are
      finished and confirmed to work fine.
      </para>

      <para>
        The file tree structure of ALSA driver is depicted below. Both
        alsa-kernel and alsa-driver have almost the same file
        structure, except for <quote>core</quote> directory. It's
        named as <quote>acore</quote> in alsa-driver tree. 

        <example>
          <title>ALSA File Tree Structure</title>
          <literallayout>
        sound
                /core
                        /oss
                        /seq
                                /oss
                                /instr
                /ioctl32
                /include
                /drivers
                        /mpu401
                        /opl3
                /i2c
                        /l3
                /synth
                        /emux
                /pci
                        /(cards)
                /isa
                        /(cards)
                /arm
                /ppc
                /sparc
                /usb
                /pcmcia /(cards)
                /oss
          </literallayout>
        </example>
      </para>
    </section>

    <section id="file-tree-core-directory">
      <title>core directory</title>
      <para>
        This directory contains the middle layer, that is, the heart
      of ALSA drivers. In this directory, the native ALSA modules are
      stored. The sub-directories contain different modules and are
      dependent upon the kernel config. 
      </para>

      <section id="file-tree-core-directory-oss">
        <title>core/oss</title>

        <para>
          The codes for PCM and mixer OSS emulation modules are stored
        in this directory. The rawmidi OSS emulation is included in
        the ALSA rawmidi code since it's quite small. The sequencer
        code is stored in core/seq/oss directory (see
        <link linkend="file-tree-core-directory-seq-oss"><citetitle>
        below</citetitle></link>).
        </para>
      </section>

      <section id="file-tree-core-directory-ioctl32">
        <title>core/ioctl32</title>

        <para>
          This directory contains the 32bit-ioctl wrappers for 64bit
        architectures such like x86-64, ppc64 and sparc64. For 32bit
        and alpha architectures, these are not compiled. 
        </para>
      </section>

      <section id="file-tree-core-directory-seq">
        <title>core/seq</title>
        <para>
          This and its sub-directories are for the ALSA
        sequencer. This directory contains the sequencer core and
        primary sequencer modules such like snd-seq-midi,
        snd-seq-virmidi, etc. They are compiled only when
        <constant>CONFIG_SND_SEQUENCER</constant> is set in the kernel
        config. 
        </para>
      </section>

      <section id="file-tree-core-directory-seq-oss">
        <title>core/seq/oss</title>
        <para>
          This contains the OSS sequencer emulation codes.
        </para>
      </section>

      <section id="file-tree-core-directory-deq-instr">
        <title>core/seq/instr</title>
        <para>
          This directory contains the modules for the sequencer
        instrument layer. 
        </para>
      </section>
    </section>

    <section id="file-tree-include-directory">
      <title>include directory</title>
      <para>
        This is the place for the public header files of ALSA drivers,
      which are to be exported to the user-space, or included by
      several files at different directories. Basically, the private
      header files should not be placed in this directory, but you may
      still find files there, due to historical reason :) 
      </para>
    </section>

    <section id="file-tree-drivers-directory">
      <title>drivers directory</title>
      <para>
        This directory contains the codes shared among different drivers
      on the different architectures.  They are hence supposed not to be
      architecture-specific.
      For example, the dummy pcm driver and the serial MIDI
      driver are found in this directory. In the sub-directories,
      there are the codes for components which are independent from
      bus and cpu architectures. 
      </para>

      <section id="file-tree-drivers-directory-mpu401">
        <title>drivers/mpu401</title>
        <para>
          The MPU401 and MPU401-UART modules are stored here.
        </para>
      </section>

      <section id="file-tree-drivers-directory-opl3">
        <title>drivers/opl3 and opl4</title>
        <para>
          The OPL3 and OPL4 FM-synth stuff is found here.
        </para>
      </section>
    </section>

    <section id="file-tree-i2c-directory">
      <title>i2c directory</title>
      <para>
        This contains the ALSA i2c components.
      </para>

      <para>
        Although there is a standard i2c layer on Linux, ALSA has its
      own i2c codes for some cards, because the soundcard needs only a
      simple operation and the standard i2c API is too complicated for
      such a purpose. 
      </para>

      <section id="file-tree-i2c-directory-l3">
        <title>i2c/l3</title>
        <para>
          This is a sub-directory for ARM L3 i2c.
        </para>
      </section>
    </section>

    <section id="file-tree-synth-directory">
        <title>synth directory</title>
        <para>
          This contains the synth middle-level modules.
        </para>

        <para>
          So far, there is only Emu8000/Emu10k1 synth driver under
        synth/emux sub-directory. 
        </para>
    </section>

    <section id="file-tree-pci-directory">
      <title>pci directory</title>
      <para>
        This and its sub-directories hold the top-level card modules
      for PCI soundcards and the codes specific to the PCI BUS.
      </para>

      <para>
        The drivers compiled from a single file is stored directly on
      pci directory, while the drivers with several source files are
      stored on its own sub-directory (e.g. emu10k1, ice1712). 
      </para>
    </section>

    <section id="file-tree-isa-directory">
      <title>isa directory</title>
      <para>
        This and its sub-directories hold the top-level card modules
      for ISA soundcards. 
      </para>
    </section>

    <section id="file-tree-arm-ppc-sparc-directories">
      <title>arm, ppc, and sparc directories</title>
      <para>
        These are for the top-level card modules which are
      specific to each given architecture. 
      </para>
    </section>

    <section id="file-tree-usb-directory">
      <title>usb directory</title>
      <para>
        This contains the USB-audio driver. On the latest version, the
      USB MIDI driver is integrated together with usb-audio driver. 
      </para>
    </section>

    <section id="file-tree-pcmcia-directory">
      <title>pcmcia directory</title>
      <para>
        The PCMCIA, especially PCCard drivers will go here. CardBus
      drivers will be on pci directory, because its API is identical
      with the standard PCI cards. 
      </para>
    </section>

    <section id="file-tree-oss-directory">
      <title>oss directory</title>
      <para>
        The OSS/Lite source files are stored here on Linux 2.6 (or
      later) tree. (In the ALSA driver tarball, it's empty, of course :) 
      </para>
    </section>
  </chapter>


<!-- ****************************************************** -->
<!-- Basic Flow for PCI Drivers  -->
<!-- ****************************************************** -->
  <chapter id="basic-flow">
    <title>Basic Flow for PCI Drivers</title>

    <section id="basic-flow-outline">
      <title>Outline</title>
      <para>
        The minimum flow of PCI soundcard is like the following:

        <itemizedlist>
          <listitem><para>define the PCI ID table (see the section
          <link linkend="pci-resource-entries"><citetitle>PCI Entries
          </citetitle></link>).</para></listitem> 
          <listitem><para>create <function>probe()</function> callback.</para></listitem>
          <listitem><para>create <function>remove()</function> callback.</para></listitem>
          <listitem><para>create pci_driver table which contains the three pointers above.</para></listitem>
          <listitem><para>create <function>init()</function> function just calling <function>pci_module_init()</function> to register the pci_driver table defined above.</para></listitem>
          <listitem><para>create <function>exit()</function> function to call <function>pci_unregister_driver()</function> function.</para></listitem>
        </itemizedlist>
      </para>
    </section>

    <section id="basic-flow-example">
      <title>Full Code Example</title>
      <para>
        The code example is shown below. Some parts are kept
      unimplemented at this moment but will be filled in the
      succeeding sections. The numbers in comment lines of
      <function>snd_mychip_probe()</function> function are the
      markers. 

        <example>
          <title>Basic Flow for PCI Drivers Example</title>
          <programlisting>
<![CDATA[
  #include <sound/driver.h>
  #include <linux/init.h>
  #include <linux/pci.h>
  #include <linux/slab.h>
  #include <sound/core.h>
  #define SNDRV_GET_ID
  #include <sound/initval.h>

  // module parameters (see "Module Parameters")
  static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
  static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
  static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;

  // definition of the chip-specific record
  typedef struct snd_mychip mychip_t;
  struct snd_mychip {
          snd_card_t *card;
          // rest of implementation will be in the section
          // "PCI Resource Managements"
  };

  // this should be go into <sound/sndmagic.h>
  // (see "Management of Cards and Components")
  #define mychip_t_magic        0xa15a4501

  // chip-specific destructor
  // (see "PCI Resource Managements")
  static int snd_mychip_free(mychip_t *chip)
  {
          // will be implemented later...
  }

  // component-destructor
  // (see "Management of Cards and Components")
  static int snd_mychip_dev_free(snd_device_t *device)
  {
          mychip_t *chip = snd_magic_cast(mychip_t,
                  device->device_data, return -ENXIO);
          return snd_mychip_free(chip);
  }

  // chip-specific constructor
  // (see "Management of Cards and Components")
  static int __devinit snd_mychip_create(snd_card_t *card,
                                         struct pci_dev *pci,
                                         mychip_t **rchip)
  {
          mychip_t *chip;
          int err;
          static snd_device_ops_t ops = {
                 .dev_free = snd_mychip_dev_free,
          };

          *rchip = NULL;

          // check PCI availability here
          // (see "PCI Resource Managements")

          // allocate a chip-specific data with magic-alloc
          chip = snd_magic_kcalloc(mychip_t, 0, GFP_KERNEL);
          if (chip == NULL)
                  return -ENOMEM;

          chip->card = card;

          // rest of initialization here; will be implemented
          // later, see "PCI Resource Managements"

          if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL,
                                    chip, &ops)) < 0) {
                  snd_mychip_free(chip);
                  return err;
          }
          *rchip = chip;
          return 0;
  }

  // constructor -- see "Constructor" sub-section
  static int __devinit snd_mychip_probe(struct pci_dev *pci,
                               const struct pci_device_id *pci_id)
  {
          static int dev;
          snd_card_t *card;
          mychip_t *chip;
          int err;

          // (1)
          if (dev >= SNDRV_CARDS)
                  return -ENODEV;
          if (!enable[dev]) {
                  dev++;
                  return -ENOENT;
          }

          // (2)
          card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
          if (card == NULL)
                  return -ENOMEM;

          // (3)
          if ((err = snd_mychip_create(card, pci, &chip)) < 0) {
                  snd_card_free(card);
                  return err;
          }

          // (4)
          strcpy(card->driver, "My Chip");
          strcpy(card->shortname, "My Own Chip 123");
          sprintf(card->longname, "%s at 0x%lx irq %i",
                  card->shortname, chip->ioport, chip->irq);

          // (5)
          // implemented later

          // (6)
          if ((err = snd_card_register(card)) < 0) {
                  snd_card_free(card);
                  return err;
          }

          // (7)
          pci_set_drvdata(pci, card);
          dev++;
          return 0;
  }

  // destructor -- see "Destructor" sub-section
  static void __devexit snd_mychip_remove(struct pci_dev *pci)
  {
          snd_card_free(pci_get_drvdata(pci));
          pci_set_drvdata(pci, NULL);
  }
]]>
          </programlisting>
        </example>
      </para>
    </section>

    <section id="basic-flow-constructor">
      <title>Constructor</title>
      <para>
        The real constructor of PCI drivers is probe callback. The
      probe callback and other component-constructors which are called
      from probe callback should be defined with
      <parameter>__devinit</parameter> prefix. You 
      cannot use <parameter>__init</parameter> prefix for them,
      because any PCI device could be a hotplug device. 
      </para>

      <para>
        In the probe callback, the following scheme is often used.
      </para>

      <section id="basic-flow-constructor-device-index">
        <title>1) Check and increment the device index.</title>
        <para>
          <informalexample>
            <programlisting>
<![CDATA[
  static int dev;
  ....
  if (dev >= SNDRV_CARDS)
          return -ENODEV;
  if (!enable[dev]) {
          dev++;
          return -ENOENT;
  }
]]>
            </programlisting>
          </informalexample>

        where enable[dev] is the module option.
        </para>

        <para>
          At each time probe callback is called, check the
        availability of the device. If not available, simply increment
        the device index and returns. dev will be incremented also
        later (<link
        linkend="basic-flow-constructor-set-pci"><citetitle>step
        7</citetitle></link>). 
        </para>
      </section>

      <section id="basic-flow-constructor-create-card">
        <title>2) Create a card instance</title>
        <para>
          <informalexample>
            <programlisting>
<![CDATA[
  snd_card_t *card;
  ....
  card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
]]>
            </programlisting>
          </informalexample>
        </para>

        <para>
          The detail will be explained in the section
          <link linkend="card-management-card-instance"><citetitle>
          Management of Cards and Components</citetitle></link>.
        </para>
      </section>

      <section id="basic-flow-constructor-create-main">
        <title>3) Create a main component</title>
        <para>
          In this part, the PCI resources are allocated.

          <informalexample>
            <programlisting>
<![CDATA[
  mychip_t *chip;
  ....
  if ((err = snd_mychip_create(card, pci, &chip)) < 0) {
          snd_card_free(card);
          return err;
  }
]]>
            </programlisting>
          </informalexample>

          The detail will be explained in the section <link
        linkend="pci-resource"><citetitle>PCI Resource
        Managements</citetitle></link>.
        </para>
      </section>

      <section id="basic-flow-constructor-main-component">
        <title>4) Set the driver ID and name strings.</title>
        <para>
          <informalexample>
            <programlisting>
<![CDATA[
  strcpy(card->driver, "My Chip");
  strcpy(card->shortname, "My Own Chip 123");
  sprintf(card->longname, "%s at 0x%lx irq %i",
          card->shortname, chip->ioport, chip->irq);
]]>
            </programlisting>
          </informalexample>

          The driver field holds the minimal ID string of the
        chip. This is referred by alsa-lib's configurator, so keep it
        simple but unique. 
          Even the same driver can have different driver IDs to
        distinguish the functionality of each chip type. 
        </para>

        <para>
          The shortname field is a string shown as more verbose
        name. The longname field contains the information which is
        shown in <filename>/proc/asound/cards</filename>. 
        </para>
      </section>

      <section id="basic-flow-constructor-create-other">
        <title>5) Create other components, such as mixer, MIDI, etc.</title>
        <para>
          Here you define the basic components such as
          <link linkend="pcm-interface"><citetitle>PCM</citetitle></link>,
          mixer (e.g. <link linkend="api-ac97"><citetitle>AC97</citetitle></link>),
          MIDI (e.g. <link linkend="midi-interface"><citetitle>MPU-401</citetitle></link>),
          and other interfaces.
          Also, if you want a <link linkend="proc-interface"><citetitle>proc
        file</citetitle></link>, define it here, too.
        </para>
      </section>

      <section id="basic-flow-constructor-register-card">
        <title>6) Register the card instance.</title>
        <para>
          <informalexample>
            <programlisting>
<![CDATA[
  if ((err = snd_card_register(card)) < 0) {
          snd_card_free(card);
          return err;
  }
]]>
            </programlisting>
          </informalexample>
        </para>

        <para>
          Will be explained in the section <link
        linkend="card-management-registration"><citetitle>Management
        of Cards and Components</citetitle></link>, too. 
        </para>
      </section>

      <section id="basic-flow-constructor-set-pci">
        <title>7) Set the PCI driver data and return zero.</title>
        <para>
          <informalexample>
            <programlisting>
<![CDATA[
        pci_set_drvdata(pci, card);
        dev++;
        return 0;
]]>
            </programlisting>
          </informalexample>

          In the above, the card record is stored. This pointer is
        referred in the remove callback and power-management
        callbacks, too. 
        </para>
      </section>
    </section>

    <section id="basic-flow-destructor">
      <title>Destructor</title>
      <para>
        The destructor, remove callback, simply releases the card
      instance. Then the ALSA middle layer will release all the
      attached components automatically. 
      </para>

      <para>
        It would be typically like the following:

        <informalexample>
          <programlisting>
<![CDATA[
  static void __devexit snd_mychip_remove(struct pci_dev *pci)
  {
          snd_card_free(pci_get_drvdata(pci));
          pci_set_drvdata(pci, NULL);
  }
]]>
          </programlisting>
        </informalexample>

        The above code assumes that the card pointer is set to the PCI
	driver data.
      </para>
    </section>

    <section id="basic-flow-header-files">
      <title>Header Files</title>
      <para>
        For the above example, at least the following include files
      are necessary. 

        <informalexample>
          <programlisting>
<![CDATA[
  #include <sound/driver.h>
  #include <linux/init.h>
  #include <linux/pci.h>
  #include <linux/slab.h>
  #include <sound/core.h>
  #define SNDRV_GET_ID
  #include <sound/initval.h>
]]>
          </programlisting>
        </informalexample>

	where the last twos are necessary only when module options are
      defined in the source file.  If the codes are split to several
      files, the file without module options don't need them.
      </para>

      <para>
        In addition to them, you'll need
      <filename>&lt;linux/interrupt.h&gt;</filename> for the interrupt
      handling, and <filename>&lt;asm/io.h&gt;</filename> for the i/o
      access. If you use <function>mdelay()</function> or
      <function>udelay()</function> functions, you'll need to include
      <filename>&lt;linux/delay.h&gt;</filename>, too. 
      </para>

      <para>
      The ALSA interfaces like PCM or control API are define in other
      header files as <filename>&lt;sound/xxx.h&gt;</filename>.
      They have to be included after
      <filename>&lt;sound/core.h&gt;</filename>.
      </para>

    </section>
  </chapter>


<!-- ****************************************************** -->
<!-- Management of Cards and Components  -->
<!-- ****************************************************** -->
  <chapter id="card-management">
    <title>Management of Cards and Components</title>

    <section id="card-management-card-instance">
      <title>Card Instance</title>
      <para>
      For each soundcard, a <quote>card</quote> record must be allocated.
      </para>

      <para>
      A card record is the headquarters of the soundcard.  It manages
      the list of whole devices (components) on the soundcard, such as
      PCM, mixers, MIDI, synthesizer, and so on.  Also, the card
      record holds the ID and the name strings of the card, manages
      the root of proc files, and controls the power-management states
      and hotplug disconnections.  The component list on the card
      record is used to manage the proper releases of resources at
      destruction. 
      </para>

      <para>
        As mentioned above, to create a card instance, call
      <function>snd_card_new()</function>.

        <informalexample>
          <programlisting>
<![CDATA[
  snd_card_t *card;
  card = snd_card_new(index, id, module, extra_size);
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        The function takes four arguments, the card-index number, the
        id string, the module pointer (usually
        <constant>THIS_MODULE</constant>),
        and the size of extra-data space.  The last argument is used to
        allocate card-&gt;private_data for the
        chip-specific data.  Note that this data
        <emphasis>is</emphasis> allocated by
        <function>snd_card_new()</function>.
      </para>
    </section>

    <section id="card-management-component">
      <title>Components</title>
      <para>
        After the card is created, you can attach the components
      (devices) to the card instance. On ALSA driver, a component is
      represented as a <type>snd_device_t</type> object.
      A component can be a PCM instance, a control interface, a raw
      MIDI interface, etc.  Each of such instances has one component
      entry.
      </para>

      <para>
        A component can be created via
        <function>snd_device_new()</function> function. 

        <informalexample>
          <programlisting>
<![CDATA[
  snd_device_new(card, SNDRV_DEV_XXX, chip, &ops);
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        This takes the card pointer, the device-level
      (<constant>SNDRV_DEV_XXX</constant>), the data pointer, and the
      callback pointers (<parameter>&amp;ops</parameter>). The
      device-level defines the type of components and the order of
      registration and de-registration.  For most of components, the
      device-level is already defined.  For a user-defined component,
      you can use <constant>SNDRV_DEV_LOWLEVEL</constant>.
      </para>

      <para>
      This function itself doesn't allocate the data space. The data
      must be allocated manually beforehand, and its pointer is passed
      as the argument. This pointer is used as the identifier
      (<parameter>chip</parameter> in the above example) for the
      instance. 
      </para>

      <para>
        Each ALSA pre-defined component such as ac97 or pcm calls
      <function>snd_device_new()</function> inside its
      constructor. The destructor for each component is defined in the
      callback pointers.  Hence, you don't need to take care of
      calling a destructor for such a component.
      </para>

      <para>
        If you would like to create your own component, you need to
      set the destructor function to dev_free callback in
      <parameter>ops</parameter>, so that it can be released
      automatically via <function>snd_card_free()</function>. The
      example will be shown later as an implementation of a
      chip-specific data. 
      </para>
    </section>

    <section id="card-management-chip-specific">
      <title>Chip-Specific Data</title>
      <para>
      The chip-specific information, e.g. the i/o port address, its
      resource pointer, or the irq number, is stored in the
      chip-specific record.
      Usually, the chip-specific record is typedef'ed as
      <type>xxx_t</type> like the following:

        <informalexample>
          <programlisting>
<![CDATA[
  typedef struct snd_mychip mychip_t;
  struct snd_mychip {
          ....
  };
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        You might have objections against such a typedef, but this
      typedef is necessary if you use a <quote>magic-cast</quote>
      (explained <link
      linkend="card-management-chip-what-advantage"><citetitle>later</citetitle></link>). 
      </para>

      <para>
        In general, there are two ways to allocate the chip record.
      </para>

      <section id="card-management-chip-specific-snd-card-new">
        <title>1. Allocating via <function>snd_card_new()</function>.</title>
        <para>
          As mentioned above, you can pass the extra-data-length to the 4th argument of <function>snd_card_new()</function>, i.e.

          <informalexample>
            <programlisting>
<![CDATA[
  card = snd_card_new(index[dev], id[dev], THIS_MODULE, sizeof(mychip_t));
]]>
            </programlisting>
          </informalexample>

          whether <type>mychip_t</type> is the type of the chip record.
        </para>

        <para>
          In return, the allocated record can be accessed as

          <informalexample>
            <programlisting>
<![CDATA[
  mychip_t *chip = (mychip_t *)card->private_data;
]]>
            </programlisting>
          </informalexample>

          With this method, you don't have to allocate twice. But you
        cannot use <quote>magic-cast</quote> for this record pointer,
        instead. 
        </para>
      </section>

      <section id="card-management-chip-specific-allocate-extra">
        <title>2. Allocating an extra device.</title>

        <para>
          After allocating a card instance via
          <function>snd_card_new()</function> (with
          <constant>NULL</constant> on the 4th arg), call
          <function>snd_magic_kcalloc()</function>. 

          <informalexample>
            <programlisting>
<![CDATA[
  snd_card_t *card;
  mychip_t *chip;
  card = snd_card_new(index[dev], id[dev], THIS_MODULE, NULL);
  .....
  chip = snd_magic_kcalloc(mychip_t, 0, GFP_KERNEL);
]]>
            </programlisting>
          </informalexample>

          Once when the record is allocated via snd_magic stuff, you
        can use <quote>magic-cast</quote> for the void pointer. 
        </para>

        <para>
          The chip record should have the field to hold the card
          pointer at least, 

          <informalexample>
            <programlisting>
<![CDATA[
  struct snd_mychip {
          snd_card_t *card;
          ....
  };
]]>
            </programlisting>
          </informalexample>
        </para>

        <para>
          Then, set the card pointer in the returned chip instance.

          <informalexample>
            <programlisting>
<![CDATA[
  chip->card = card;
]]>
            </programlisting>
          </informalexample>
        </para>

        <para>
          Also, you need to define a magic-value for <type>mychip_t</type>.

          <informalexample>
            <programlisting>
<![CDATA[
  #define mychip_t_magic        0xa15a4501
]]>
            </programlisting>
          </informalexample>
	(the detail will be described in the
	<link linkend="card-management-chip-what-advantage"><citetitle>
	next</citetitle></link> subsection).
	</para>

        <para>
          Next, initialize the fields, and register this chip
          record as a low-level device with a specified
          <parameter>ops</parameter>, 

          <informalexample>
            <programlisting>
<![CDATA[
  static snd_device_ops_t ops = {
          .dev_free =        snd_mychip_dev_free,
  };
  ....
  snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);
]]>
            </programlisting>
          </informalexample>

          <function>snd_mychip_dev_free()</function> is the
        device-destructor function, which will call the real
        destructor. 
        </para>

        <para>
          <informalexample>
            <programlisting>
<![CDATA[
  static int snd_mychip_dev_free(snd_device_t *device)
  {
          mychip_t *chip = snd_magic_cast(mychip_t, device->device_data,
                                          return -ENXIO);
          return snd_mychip_free(chip);
  }
]]>
            </programlisting>
          </informalexample>

          where <function>snd_mychip_free()</function> is the real destructor.
        </para>
      </section>

      <section id="card-management-chip-what-advantage">
        <title>Not a magic but a logic</title>

        <para>Now, you might have a question: What is the advantage of the
        second method?  Obviously, it looks far more complicated.</para> 
        <para>
          As I wrote many times, the second method allows a
        <quote>magic-cast</quote> for <type>mychip_t</type>. If you
        have a void pointer (such as
        pcm-&gt;private_data), the pointer type
        is unknown at the compile time, and you cannot know even if a
        wrong pointer type is passed. The compiler would accept
        it. The magic-cast checks the pointer type at the runtime (and
        whether it's a null pointer, too). Hence, the cast will be
        much safer and good for debugging. 
        </para>

	<para>
	As you have already seen, allocation with a magic-header can
	be done via <function>snd_magic_kmalloc()</function> or
	<function>snd_magic_kcalloc()</function>.

          <informalexample>
            <programlisting>
<![CDATA[
  mychip_t *chip;
  chip = snd_magic_kmalloc(mychip_t, 0, GFP_KERNEL);
  chip = snd_magic_kcalloc(mychip_t, 0, GFP_KERNEL);
]]>
            </programlisting>
          </informalexample>

        The difference of these two functions is whether the area is
	zero-cleared (<function>kcalloc</function>) or not
	(<function>kmalloc</function>).
	</para>

	<para>
	The first argument of the allocator is the type of the
	record.  The magic-constant has to be defined for this type
	beforehand.  In this case, we'll need to define
	<constant>mychip_t_magic</constant>, for example, as already
	seen,

          <informalexample>
            <programlisting>
<![CDATA[
  #define mychip_t_magic        0xa15a4501
]]>
            </programlisting>
          </informalexample>

        The value is arbitrary but should be unique.
        This is usually defined in
        <filename>&lt;include/sndmagic.h&gt;</filename> or
        <filename>&lt;include/amagic.h&gt;</filename> for alsa-driver tree,
        but you may define it locally in the code at the early
        development stage, since changing
        <filename>sndmagic.h</filename> will lead to the recompilation
        of the whole driver codes.
        </para>

	<para>
	The second argument is the extra-data length.  It is usually
        zero.  The third argument is the flags to be passed to kernel
        memory allocator, <constant>GFP_XXX</constant>.  Normally,
        <constant>GFP_KERNEL</constant> is passed.
	</para>

        <para>
          For casting a pointer, use
          <function>snd_magic_cast()</function> macro:

          <informalexample>
            <programlisting>
<![CDATA[
  mychip_t *chip = snd_magic_cast(mychip_t, source_pointer, action);
]]>
            </programlisting>
          </informalexample>

        where <parameter>source_pointer</parameter> is the pointer to
        be casted (e.g. pcm-&gt;private_data), and
        <parameter>action</parameter> is the action to do if the cast
        fails (e.g. return <constant>-EINVAL</constant>). 
        </para>

	<para>
	For releasing the magic-allocated data, you need to call
        <function>snd_magic_kfree()</function> function instead of
        <function>kfree()</function>.

          <informalexample>
            <programlisting>
<![CDATA[
  snd_magic_kfree(chip);
]]>
            </programlisting>
          </informalexample>
	</para>

	<para>
	If you call <function>kfree()</function> for the
	magic-allocated value, it will lead to memory leaks.
	When the ALSA drivers are compiled with
	<constant>CONFIG_SND_DEBUG_MEMORY</constant> kernel config (or
	configured with <option>--with-debug=full</option>), the
	non-matching free will be checked and you'll see warning
	messages.
	</para>

        <para>
          If you are 100% sure that your code is bug-free, you can
          compile the driver without
          <constant>CONFIG_SND_DEBUG_MEMORY</constant> kernel config,
          so that the magic-allocator and the magic-cast will be
          replaced to the normal kmalloc and cast.
        </para>
      </section>
    </section>

    <section id="card-management-registration">
      <title>Registration and Release</title>
      <para>
        After all components are assigned, register the card instance
      by calling <function>snd_card_register()</function>. The access
      to the device files are enabled at this point. That is, before
      <function>snd_card_register()</function> is called, the
      components are safely inaccessible from external side. If this
      call fails, exit the probe function after releasing the card via
      <function>snd_card_free()</function>. 
      </para>

      <para>
        For releasing the card instance, you can call simply
      <function>snd_card_free()</function>. As already mentioned, all
      components are released automatically by this call. 
      </para>

      <para>
        As further notes, the destructors (both
      <function>snd_mychip_dev_free</function> and
      <function>snd_mychip_free</function>) cannot be defined with
      <parameter>__devexit</parameter> prefix, because they may be
      called from the constructor, too, at the false path. 
      </para>

      <para>
      For a device which allows hotplugging, you can use
      <function>snd_card_free_in_thread</function>.  This one will
      postpone the destruction and wait in a kernel-thread until all
      devices are closed.
      </para>

    </section>

  </chapter>


<!-- ****************************************************** -->
<!-- PCI Resource Managements  -->
<!-- ****************************************************** -->
  <chapter id="pci-resource">
    <title>PCI Resource Managements</title>

    <section id="pci-resource-example">
      <title>Full Code Example</title>
      <para>
        In this section, we'll finish the chip-specific constructor,
      destructor and PCI entries. The example code is shown first,
      below. 

        <example>
          <title>PCI Resource Managements Example</title>
          <programlisting>
<![CDATA[
  struct snd_mychip {
          snd_card_t *card;
          struct pci_dev *pci;

          unsigned long port;
          struct resource *res_port;

          int irq;
  };

  static int snd_mychip_free(mychip_t *chip)
  {
          // disable hardware here if any
          // (not implemented in this document)

          // release the i/o port
          if (chip->res_port) {
                  release_resource(chip->res_port);
                  kfree_nocheck(chip->res_port);
          }
          // release the irq
          if (chip->irq >= 0)
                  free_irq(chip->irq, (void *)chip);
          // release the data
          snd_magic_kfree(chip);
          return 0;
  }

  // chip-specific constructor
  static int __devinit snd_mychip_create(snd_card_t *card,
                                         struct pci_dev *pci,
                                         mychip_t **rchip)
  {
          mychip_t *chip;
          int err;
          static snd_device_ops_t ops = {
                 .dev_free = snd_mychip_dev_free,
          };

          *rchip = NULL;

          // check PCI availability (28bit DMA)
          if ((err = pci_enable_device(pci)) < 0)
                  return err;
          if (pci_set_dma_mask(pci, 0x0fffffff) < 0 ||
              pci_set_consistent_dma_mask(pci, 0x0fffffff) < 0) {
                  printk(KERN_ERR "error to set 28bit mask DMA\n");
                  return -ENXIO;
          }

          chip = snd_magic_kcalloc(mychip_t, 0, GFP_KERNEL);
          if (chip == NULL)
                  return -ENOMEM;

          // initialize the stuff
          chip->card = card;
          chip->pci = pci;
          chip->irq = -1;

          // (1) PCI resource allocation
          chip->port = pci_resource_start(pci, 0);
          if ((chip->res_port = request_region(chip->port, 8,
                                                 "My Chip")) == NULL) { 
                  snd_mychip_free(chip);
                  printk(KERN_ERR "cannot allocate the port\n");
                  return -EBUSY;
          }
          if (request_irq(pci->irq, snd_mychip_interrupt,
                          SA_INTERRUPT|SA_SHIRQ, "My Chip",
                          (void *)chip)) {
                  snd_mychip_free(chip);
                  printk(KERN_ERR "cannot grab irq\n");
                  return -EBUSY;
          }
          chip->irq = pci->irq;

          // (2) initialization of the chip hardware
          //     (not implemented in this document)

          if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL,
                                    chip, &ops)) < 0) {
                  snd_mychip_free(chip);
                  return err;
          }
          *rchip = chip;
          return 0;
  }        

  // PCI IDs
  static struct pci_device_id snd_mychip_ids[] = {
          { PCI_VENDOR_ID_FOO, PCI_DEVICE_ID_BAR,
            PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
          ....
          { 0, }
  };
  MODULE_DEVICE_TABLE(pci, snd_mychip_ids);

  // pci_driver definition
  static struct pci_driver driver = {
          .name = "My Own Chip",
          .id_table = snd_mychip_ids,
          .probe = snd_mychip_probe,
          .remove = __devexit_p(snd_mychip_remove),
  };

  // initialization of the module
  static int __init alsa_card_mychip_init(void)
  {
          return pci_module_init(&driver);
  }

  // clean up the module
  static void __exit alsa_card_mychip_exit(void)
  {
          pci_unregister_driver(&driver);
  }

  module_init(alsa_card_mychip_init)
  module_exit(alsa_card_mychip_exit)

  EXPORT_NO_SYMBOLS; /* for old kernels only */
]]>
          </programlisting>
        </example>
      </para>
    </section>

    <section id="pci-resource-some-haftas">
      <title>Some Hafta's</title>
      <para>
        The allocation of PCI resources is done in the
      <function>probe()</function> function, and usually an extra
      <function>xxx_create()</function> function is written for this
      purpose. 
      </para>

      <para>
        In the case of PCI devices, you have to call at first
      <function>pci_enable_device()</function> function before
      allocating resources. Also, you need to set the proper PCI DMA
      mask to limit the accessed i/o range. In some cases, you might
      need to call <function>pci_set_master()</function> function,
      too. 
      </para>

      <para>
        Suppose the 28bit mask, and the code to be added would be like:

        <informalexample>
          <programlisting>
<![CDATA[
  if ((err = pci_enable_device(pci)) < 0)
          return err;
  if (pci_set_dma_mask(pci, 0x0fffffff) < 0 ||
      pci_set_consistent_dma_mask(pci, 0x0fffffff) < 0) {
          printk(KERN_ERR "error to set 28bit mask DMA\n");
          return -ENXIO;
  }
  
]]>
          </programlisting>
        </informalexample>
      </para>
    </section>

    <section id="pci-resource-resource-allocation">
      <title>Resource Allocation</title>
      <para>
        The allocation of I/O ports and irqs are done via standard kernel
      functions. Unlike ALSA ver.0.5.x., there are no helpers for
      that. And these resources must be released in the destructor
      function (see below). Also, on ALSA 0.9.x, you don't need to
      allocate (pseudo-)DMA for PCI like ALSA 0.5.x. 
      </para>

      <para>
        Now assume that this PCI device has an I/O port with 8 bytes
        and an interrupt. Then <type>mychip_t</type> will have the
        following fields: 

        <informalexample>
          <programlisting>
<![CDATA[
  struct snd_mychip {
          snd_card_t *card;

          unsigned long port;
          struct resource *res_port;

          int irq;
  };
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        For an i/o port (and also a memory region), you need to have
      the resource pointer for the standard resource management. For
      an irq, you have to keep only the irq number (integer). But you
      need to initialize this number as -1 before actual allocation,
      since irq 0 is valid. The port address and its resource pointer
      can be initialized as null by
      <function>snd_magic_kcalloc()</function> automatically, so you
      don't have to take care of resetting them. 
      </para>

      <para>
        The allocation of an i/o port is done like this:

        <informalexample>
          <programlisting>
<![CDATA[
  chip->port = pci_resource_start(pci, 0);
  if ((chip->res_port = request_region(chip->port, 8,
                                       "My Chip")) == NULL) { 
          printk(KERN_ERR "cannot allocate the port 0x%lx\n",
                 chip->port);
          snd_mychip_free(chip);
          return -EBUSY;
  }
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        It will reserve the i/o port region of 8 bytes of the given
      PCI device. The returned value, chip-&gt;res_port, is allocated
      via <function>kmalloc()</function> by
      <function>request_region()</function>. The pointer must be
      released via <function>kfree()</function>, but there is some
      problem regarding this. This issue will be explained more below.
      </para>

      <para>
        The allocation of an interrupt source is done like this:

        <informalexample>
          <programlisting>
<![CDATA[
  if (request_irq(pci->irq, snd_mychip_interrupt,
                  SA_INTERRUPT|SA_SHIRQ, "My Chip",
                  (void *)chip)) {
          snd_mychip_free(chip);
          printk(KERN_ERR "cannot grab irq %d\n", pci->irq);
          return -EBUSY;
  }
  chip->irq = pci->irq;
]]>
          </programlisting>
        </informalexample>

        where <function>snd_mychip_interrupt()</function> is the
      interrupt handler defined <link
      linkend="pcm-interface-interrupt-handler"><citetitle>later</citetitle></link>.
      Note that chip-&gt;irq should be defined
      only when <function>request_irq()</function> succeeded.
      </para>

      <para>
      On the PCI bus, the interrupts can be shared. Thus,
      <constant>SA_SHIRQ</constant> is given as the interrupt flag of
      <function>request_irq()</function>. 
      </para>

      <para>
        The last argument of <function>request_irq()</function> is the
      data pointer passed to the interrupt handler. Usually, the
      chip-specific record is used for that, but you can use what you
      like, too. 
      </para>

      <para>
        I won't define the detail of the interrupt handler at this
        point, but at least its appearance can be explained now. The
        interrupt handler looks usually like the following: 

        <informalexample>
          <programlisting>
<![CDATA[
  static irqreturn_t snd_mychip_interrupt(int irq, void *dev_id,
                                          struct pt_regs *regs)
  {
          mychip_t *chip = snd_magic_cast(mychip_t, dev_id, return);
          ....
          return IRQ_HANDLED;
  }
]]>
          </programlisting>
        </informalexample>

        Again the magic-cast is used here to get the correct pointer
      from the second argument. 
      </para>

      <para>
        Now let's write the corresponding destructor for the resources
      above. The role of destructor is simple: disable the hardware
      (if already activated) and release the resources. So far, we
      have no hardware part, so the disabling is not written here. 
      </para>

      <para>
        For releasing the resources, <quote>check-and-release</quote>
        method is a safer way. For the i/o port, do like this: 

        <informalexample>
          <programlisting>
<![CDATA[
  if (chip->res_port) {
          release_resource(chip->res_port);
          kfree_nocheck(chip->res_port);
  }
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        As you can see, the i/o resource pointer is also to be freed
      via <function>kfree_nocheck()</function> after
      <function>release_resource()</function> is called. You
      cannot use <function>kfree()</function> here, because on ALSA,
      <function>kfree()</function> may be a wrapper to its own
      allocator with the memory debugging. Since the resource pointer
      is allocated externally outside the ALSA, it must be released
      via the native
      <function>kfree()</function>.
      <function>kfree_nocheck()</function> is used for that; it calls
      the native <function>kfree()</function> without wrapper. 
      </para>

      <para>
        For releasing the interrupt, do like this:

        <informalexample>
          <programlisting>
<![CDATA[
  if (chip->irq >= 0)
          free_irq(chip->irq, (void *)chip);
]]>
          </programlisting>
        </informalexample>

        And finally, release the chip-specific record.

        <informalexample>
          <programlisting>
<![CDATA[
  snd_magic_kfree(chip);
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        The chip instance is freed via
      <function>snd_magic_kfree()</function>. Please use this function
      for the object allocated by
      <function>snd_magic_kmalloc()</function>. If you free it with
      <function>kfree()</function>, it won't work properly and will
      result in the memory leak. Also, again, remember that you cannot
      set <parameter>__devexit</parameter> prefix for this destructor. 
      </para>

      <para>
      We didn't implement the hardware-disabling part in the above.
      If you need to do this, please note that the destructor may be
      called even before the initialization of the chip is completed.
      It would be better to have a flag to skip the hardware-disabling
      if the hardware was not initialized yet.
      </para>

      <para>
      When the chip-data is assigned to the card using
      <function>snd_device_new()</function> with
      <constant>SNDRV_DEV_LOWLELVEL</constant> , its destructor is 
      called at the last.  that is, it is assured that all other
      components like PCMs and controls have been already released.
      You don't have to call stopping PCMs, etc. explicitly, but just
      stop the hardware in the low-level.
      </para>

      <para>
        The management of a memory-mapped region is almost as same as
        the management of an i/o port. You'll need three fields like
        the following: 

        <informalexample>
          <programlisting>
<![CDATA[
  struct snd_mychip {
          ....
          unsigned long iobase_phys;
          unsigned long iobase_virt;
          struct resource *res_iobase;
  };
]]>
          </programlisting>
        </informalexample>

        and the allocation would be (assuming its size is 512 bytes):

        <informalexample>
          <programlisting>
<![CDATA[
  chip->iobase_phys = pci_resource_start(pci, 0);
  chip->iobase_virt = (unsigned long)
                      ioremap_nocache(chip->iobase_phys, 512);
  if ((chip->res_port = request_mem_region(chip->iobase_phys, 512,
                                           "My Chip")) == NULL) {
          printk(KERN_ERR "cannot allocate the memory region\n");
          snd_mychip_free(chip);
          return -EBUSY;
  }
]]>
          </programlisting>
        </informalexample>
        
        and the corresponding destructor would be:

        <informalexample>
          <programlisting>
<![CDATA[
  static int snd_mychip_free(mychip_t *chip)
  {
          ....
          if (chip->iobase_virt)
                  iounmap((void *)chip->iobase_virt);
          if (chip->res_iobase) {
                  release_resource(chip->res_iobase);
                  kfree_nocheck(chip->res_iobase);
          }
          ....
  }
]]>
          </programlisting>
        </informalexample>
      </para>

    </section>

    <section id="pci-resource-entries">
      <title>PCI Entries</title>
      <para>
        So far, so good. Let's finish the rest of missing PCI
      stuffs. At first, we need a
      <structname>pci_device_id</structname> table for this
      chipset. It's a table of PCI vendor/device ID number, and some
      masks. 
      </para>

      <para>
        For example,

        <informalexample>
          <programlisting>
<![CDATA[
  static struct pci_device_id snd_mychip_ids[] = {
          { PCI_VENDOR_ID_FOO, PCI_DEVICE_ID_BAR,
            PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
          ....
          { 0, }
  };
  MODULE_DEVICE_TABLE(pci, snd_mychip_ids);
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        The first and second fields of
      <structname>pci_device_id</structname> struct are the vendor and
      device IDs. If you have nothing special to filter the matching
      devices, you can use the rest of fields like above. The last
      field of <structname>pci_device_id</structname> struct is a
      private data for this entry. You can specify any value here, for
      example, to tell the type of different operations per each
      device IDs. Such an example is found in intel8x0 driver. 
      </para>

      <para>
        The last entry of this list is the terminator. You must
      specify this all-zero entry. 
      </para>

      <para>
        Then, prepare the <structname>pci_driver</structname> record:

        <informalexample>
          <programlisting>
<![CDATA[
  static struct pci_driver driver = {
          .name = "My Own Chip",
          .id_table = snd_mychip_ids,
          .probe = snd_mychip_probe,
          .remove = __devexit_p(snd_mychip_remove),
  };
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        The <structfield>probe</structfield> and
      <structfield>remove</structfield> functions are what we already
      defined in 
      the previous sections. The <structfield>remove</structfield> should
      be defined with 
      <function>__devexit_p()</function> macro, so that it's not
      defined for built-in (and non-hot-pluggable) case. The
      <structfield>name</structfield> 
      field is the name string of this device. Note that you must not
      use a slash <quote>/</quote> in this string. 
      </para>

      <para>
        And at last, the module entries:

        <informalexample>
          <programlisting>
<![CDATA[
  static int __init alsa_card_mychip_init(void)
  {
          return pci_module_init(&driver);
  }

  static void __exit alsa_card_mychip_exit(void)
  {
          pci_unregister_driver(&driver);
  }

  module_init(alsa_card_mychip_init)
  module_exit(alsa_card_mychip_exit)
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        Note that these module entries are tagged with
      <parameter>__init</parameter> and 
      <parameter>__exit</parameter> prefixes, not
      <parameter>__devinit</parameter> nor
      <parameter>__devexit</parameter>.
      </para>

      <para>
        Oh, one thing was forgotten. If you have no exported symbols,
        you need to declare it on 2.2 or 2.4 kernels (on 2.6 kernels
        it's not necessary, though).

        <informalexample>
          <programlisting>
<![CDATA[
  EXPORT_NO_SYMBOLS;
]]>
          </programlisting>
        </informalexample>

        That's all!
      </para>
    </section>
  </chapter>


<!-- ****************************************************** -->
<!-- PCM Interface  -->
<!-- ****************************************************** -->
  <chapter id="pcm-interface">
    <title>PCM Interface</title>

    <section id="pcm-interface-general">
      <title>General</title>
      <para>
        The PCM middle layer of ALSA is quite powerful and it is only
      necessary for each driver to implement the low-level functions
      to access its hardware.
      </para>

      <para>
        For accessing to the PCM layer, you need to include
      <filename>&lt;sound/pcm.h&gt;</filename> above all. In addition,
      <filename>&lt;sound/pcm_params.h&gt;</filename> might be needed
      if you access to some functions related with hw_param. 
      </para>

      <para>
        Each card device can have up to four pcm instances. A pcm
      instance corresponds to a pcm device file. The limitation of
      number of instances comes only from the available bit size of
      the linux's device number. Once when 64bit device number is
      used, we'll have more available pcm instances. 
      </para>

      <para>
        A pcm instance consists of pcm playback and capture streams,
      and each pcm stream consists of one or more pcm substreams. Some
      soundcard supports the multiple-playback function. For example,
      emu10k1 has a PCM playback of 32 stereo substreams. In this case, at
      each open, a free substream is (usually) automatically chosen
      and opened. Meanwhile, when only one substream exists and it was
      already opened, the succeeding open will result in the blocking
      or the error with <constant>EAGAIN</constant> according to the
      file open mode. But you don't have to know the detail in your
      driver. The PCM middle layer will take all such jobs. 
      </para>
    </section>

    <section id="pcm-interface-example">
      <title>Full Code Example</title>
      <para>
      The example code below does not include any hardware access
      routines but shows only the skeleton, how to build up the PCM
      interfaces.

        <example>
          <title>PCM Example Code</title>
          <programlisting>
<![CDATA[
  #include <sound/pcm.h>
  ....

  #define chip_t mychip_t
  ....

  /* hardware definition */
  static snd_pcm_hardware_t snd_mychip_playback_hw = {
          .info = (SNDRV_PCM_INFO_MMAP |
                   SNDRV_PCM_INFO_INTERLEAVED |
                   SNDRV_PCM_INFO_BLOCK_TRANSFER |
                   SNDRV_PCM_INFO_MMAP_VALID),
          .formats =          SNDRV_PCM_FMTBIT_S16_LE,
          .rates =            SNDRV_PCM_RATE_8000_48000,
          .rate_min =         8000,
          .rate_max =         48000,
          .channels_min =     2,
          .channels_max =     2,
          .buffer_bytes_max = 32768,
          .period_bytes_min = 4096,
          .period_bytes_max = 32768,
          .periods_min =      1,
          .periods_max =      1024,
  };

  /* hardware definition */
  static snd_pcm_hardware_t snd_mychip_capture_hw = {
          .info = (SNDRV_PCM_INFO_MMAP |
                   SNDRV_PCM_INFO_INTERLEAVED |
                   SNDRV_PCM_INFO_BLOCK_TRANSFER |
                   SNDRV_PCM_INFO_MMAP_VALID),
          .formats =          SNDRV_PCM_FMTBIT_S16_LE,
          .rates =            SNDRV_PCM_RATE_8000_48000,
          .rate_min =         8000,
          .rate_max =         48000,
          .channels_min =     2,
          .channels_max =     2,
          .buffer_bytes_max = 32768,
          .period_bytes_min = 4096,
          .period_bytes_max = 32768,
          .periods_min =      1,
          .periods_max =      1024,
  };

  /* open callback */
  static int snd_mychip_playback_open(snd_pcm_substream_t *substream)
  {
          mychip_t *chip = snd_pcm_substream_chip(substream);
          snd_pcm_runtime_t *runtime = substream->runtime;

          runtime->hw = snd_mychip_playback_hw;
          // more hardware-initialization will be done here
          return 0;
  }

  /* close callback */
  static int snd_mychip_playback_close(snd_pcm_substream_t *substream)
  {
          mychip_t *chip = snd_pcm_substream_chip(substream);
          // the hardware-specific codes will be here
          return 0;

  }

  /* open callback */
  static int snd_mychip_capture_open(snd_pcm_substream_t *substream)
  {
          mychip_t *chip = snd_pcm_substream_chip(substream);
          snd_pcm_runtime_t *runtime = substream->runtime;

          runtime->hw = snd_mychip_capture_hw;
          // more hardware-initialization will be done here
          return 0;
  }

  /* close callback */
  static int snd_mychip_capture_close(snd_pcm_substream_t *substream)
  {
          mychip_t *chip = snd_pcm_substream_chip(substream);
          // the hardware-specific codes will be here
          return 0;

  }

  /* hw_params callback */
  static int snd_mychip_pcm_hw_params(snd_pcm_substream_t *substream,
                               snd_pcm_hw_params_t * hw_params)
  {
          return snd_pcm_lib_malloc_pages(substream,
                                     params_buffer_bytes(hw_params));
  }

  /* hw_free callback */
  static int snd_mychip_pcm_hw_free(snd_pcm_substream_t *substream)
  {
          return snd_pcm_lib_free_pages(substream);
  }

  /* prepare callback */
  static int snd_mychip_pcm_prepare(snd_pcm_substream_t *substream)
  {
          mychip_t *chip = snd_pcm_substream_chip(substream);
          snd_pcm_runtime_t *runtime = substream->runtime;

          // set up the hardware with the current configuration
          // for example...
          mychip_set_sample_format(chip, runtime->format);
          mychip_set_sample_rate(chip, runtime->rate);
          mychip_set_channels(chip, runtime->channels);
          mychip_set_dma_setup(chip, runtime->dma_area,
                               chip->buffer_size,
                               chip->period_size);
          return 0;
  }

  /* trigger callback */
  static int snd_mychip_pcm_trigger(snd_pcm_substream_t *substream,
                                    int cmd)
  {
          switch (cmd) {
          case SNDRV_PCM_TRIGGER_START:
                  // do something to start the PCM engine
                  break;
          case SNDRV_PCM_TRIGGER_STOP:
                  // do something to stop the PCM engine
                  break;
          default:
                  return -EINVAL;
          }
  }

  /* pointer callback */
  static snd_pcm_uframes_t
  snd_mychip_pcm_pointer(snd_pcm_substream_t *substream)
  {
          mychip_t *chip = snd_pcm_substream_chip(substream);
          unsigned int current_ptr;

          // get the current hardware pointer
          current_ptr = mychip_get_hw_pointer(chip);
          return current_ptr;
  }

  /* operators */
  static snd_pcm_ops_t snd_mychip_playback_ops = {
          .open =        snd_mychip_playback_open,
          .close =       snd_mychip_playback_close,
          .ioctl =       snd_pcm_lib_ioctl,
          .hw_params =   snd_mychip_pcm_hw_params,
          .hw_free =     snd_mychip_pcm_hw_free,
          .prepare =     snd_mychip_pcm_prepare,
          .trigger =     snd_mychip_pcm_trigger,
          .pointer =     snd_mychip_pcm_pointer,
  };

  /* operators */
  static snd_pcm_ops_t snd_mychip_capture_ops = {
          .open =        snd_mychip_capture_open,
          .close =       snd_mychip_capture_close,
          .ioctl =       snd_pcm_lib_ioctl,
          .hw_params =   snd_mychip_pcm_hw_params,
          .hw_free =     snd_mychip_pcm_hw_free,
          .prepare =     snd_mychip_pcm_prepare,
          .trigger =     snd_mychip_pcm_trigger,
          .pointer =     snd_mychip_pcm_pointer,
  };

  /*
   *  definitions of capture are omitted here...
   */

  /* create a pcm device */
  static int __devinit snd_mychip_new_pcm(mychip_t *chip)
  {
          snd_pcm_t *pcm;
          int err;

          if ((err = snd_pcm_new(chip->card, "My Chip", 0, 1, 1,
                                 &pcm)) < 0) 
                  return err;
          pcm->private_data = chip;
          strcpy(pcm->name, "My Chip");
          chip->pcm = pcm;
          /* set operators */
          snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
                          &snd_mychip_playback_ops);
          snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
                          &snd_mychip_capture_ops);
          /* pre-allocation of buffers */
          snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
                                                snd_dma_pci_data(chip->pci),
                                                64*1024, 64*1024);
          return 0;
  }
]]>
          </programlisting>
        </example>
      </para>
    </section>

    <section id="pcm-interface-constructor">
      <title>Constructor</title>
      <para>
        A pcm instance is allocated <function>snd_pcm_new()</function>
      function. It would be better to create a constructor for pcm,
      namely, 

        <informalexample>
          <programlisting>
<![CDATA[
  static int __devinit snd_mychip_new_pcm(mychip_t *chip)
  {
          snd_pcm_t *pcm;
          int err;

          if ((err = snd_pcm_new(chip->card, "My Chip", 0, 1, 1,
                                 &pcm)) < 0) 
                  return err;
          pcm->private_data = chip;
          strcpy(pcm->name, "My Chip");
          chip->pcm = pcm;
	  ....
          return 0;
  }
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        The <function>snd_pcm_new()</function> function takes the four
      arguments. The first argument is the card pointer to which this
      pcm is assigned, and the second is the ID string. 
      </para>

      <para>
        The third argument (<parameter>index</parameter>, 0 in the
      above) is the index of this new pcm. It begins from zero. When
      you will create more than one pcm instances, specify the
      different numbers in this argument. For example,
      <parameter>index</parameter> = 1 for the second PCM device.  
      </para>

      <para>
        The fourth and fifth arguments are the number of substreams
      for playback and capture, respectively. Here both 1 are given in
      the above example.  When no playback or no capture is available,
      pass 0 to the corresponding argument.
      </para>

      <para>
        If a chip supports multiple playbacks or captures, you can
      specify more numbers, but they must be handled properly in
      open/close, etc. callbacks.  When you need to know which
      substream you are referring to, then it can be obtained from
      <type>snd_pcm_substream_t</type> data passed to each callback
      as follows: 

        <informalexample>
          <programlisting>
<![CDATA[
  snd_pcm_substream_t *substream;
  int index = substream->number;
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        After the pcm is created, you need to set operators for each
        pcm stream. 

        <informalexample>
          <programlisting>
<![CDATA[
  snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
                  &snd_mychip_playback_ops);
  snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
                  &snd_mychip_capture_ops);
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        The operators are defined typically like this:

        <informalexample>
          <programlisting>
<![CDATA[
  static snd_pcm_ops_t snd_mychip_playback_ops = {
          .open =        snd_mychip_pcm_open,
          .close =       snd_mychip_pcm_close,
          .ioctl =       snd_pcm_lib_ioctl,
          .hw_params =   snd_mychip_pcm_hw_params,
          .hw_free =     snd_mychip_pcm_hw_free,
          .prepare =     snd_mychip_pcm_prepare,
          .trigger =     snd_mychip_pcm_trigger,
          .pointer =     snd_mychip_pcm_pointer,
  };
]]>
          </programlisting>
        </informalexample>

        Each of callbacks is explained in the subsection 
        <link linkend="pcm-interface-operators"><citetitle>
        Operators</citetitle></link>.
      </para>

      <para>
        After setting the operators, most likely you'd like to
        pre-allocate the buffer. For the pre-allocation, simply call
        the following: 

        <informalexample>
          <programlisting>
<![CDATA[
  snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
                                        snd_dma_pci_data(chip->pci),
                                        64*1024, 64*1024);
]]>
          </programlisting>
        </informalexample>

        It will allocate up to 64kB buffer as default. The details of
      buffer management will be described in the later section <link
      linkend="buffer-and-memory"><citetitle>Buffer and Memory
      Management</citetitle></link>. 
      </para>

      <para>
        Additionally, you can set some extra information for this pcm
        in pcm-&gt;info_flags.
        The available values are defined as
        <constant>SNDRV_PCM_INFO_XXX</constant> in
        <filename>&lt;sound/asound.h&gt;</filename>, which is used for
        the hardware definition (described later). When your soundchip
        supports only half-duplex, specify like this: 

        <informalexample>
          <programlisting>
<![CDATA[
  pcm->info_flags = SNDRV_PCM_INFO_HALF_DUPLEX;
]]>
          </programlisting>
        </informalexample>
      </para>
    </section>

    <section id="pcm-interface-destructor">
      <title>... And the Destructor?</title>
      <para>
        The destructor for a pcm instance is not always
      necessary. Since the pcm device will be released by the middle
      layer code automatically, you don't have to call destructor
      explicitly.
      </para>

      <para>
        The destructor would be necessary when you created some
        special records internally and need to release them. In such a
        case, set the destructor function to
        pcm-&gt;private_free: 

        <example>
          <title>PCM Instance with a Destructor</title>
          <programlisting>
<![CDATA[
  static void mychip_pcm_free(snd_pcm_t *pcm)
  {
          mychip_t *chip = snd_magic_cast(mychip_t,
                                    pcm->private_data, return);
          // free your own data
          kfree(chip->my_private_pcm_data);
          // do what you like else...
  }

  static int __devinit snd_mychip_new_pcm(mychip_t *chip)
  {
          snd_pcm_t *pcm;
          ....
          // allocate your own data
          chip->my_private_pcm_data = kmalloc(...);
          // set the destructor
          pcm->private_data = chip;
          pcm->private_free = mychip_pcm_free;
          ....
  }
]]>
          </programlisting>
        </example>
      </para>
    </section>

    <section id="pcm-interface-runtime">
      <title>Runtime Pointer - The Chest of PCM Information</title>
	<para>
	  When the PCM substream is opened, a PCM runtime instance is
	allocated and assigned to the substream. This pointer is
	accessible via <constant>substream-&gt;runtime</constant>.
	This runtime pointer holds the various information; it holds
	the copy of hw_params and sw_params configurations, the buffer
	pointers, mmap records, spinlocks, etc.  Almost everyhing you
	need for controlling the PCM can be found there.
	</para>

	<para>
	The definition of runtime instance is found in
	<filename>&lt;sound/pcm.h&gt;</filename>.  Here is the
	copy from the file.
          <informalexample>
            <programlisting>
<![CDATA[
struct _snd_pcm_runtime {
	/* -- Status -- */
	snd_pcm_substream_t *trigger_master;
	snd_timestamp_t trigger_tstamp;	/* trigger timestamp */
	int overrange;
	snd_pcm_uframes_t avail_max;
	snd_pcm_uframes_t hw_ptr_base;	/* Position at buffer restart */
	snd_pcm_uframes_t hw_ptr_interrupt; /* Position at interrupt time*/

	/* -- HW params -- */
	snd_pcm_access_t access;	/* access mode */
	snd_pcm_format_t format;	/* SNDRV_PCM_FORMAT_* */
	snd_pcm_subformat_t subformat;	/* subformat */
	unsigned int rate;		/* rate in Hz */
	unsigned int channels;		/* channels */
	snd_pcm_uframes_t period_size;	/* period size */
	unsigned int periods;		/* periods */
	snd_pcm_uframes_t buffer_size;	/* buffer size */
	unsigned int tick_time;		/* tick time */
	snd_pcm_uframes_t min_align;	/* Min alignment for the format */
	size_t byte_align;
	unsigned int frame_bits;
	unsigned int sample_bits;
	unsigned int info;
	unsigned int rate_num;
	unsigned int rate_den;

	/* -- SW params -- */
	int tstamp_timespec;		/* use timeval (0) or timespec (1) */
	snd_pcm_tstamp_t tstamp_mode;	/* mmap timestamp is updated */
  	unsigned int period_step;
	unsigned int sleep_min;		/* min ticks to sleep */
	snd_pcm_uframes_t xfer_align;	/* xfer size need to be a multiple */
	snd_pcm_uframes_t start_threshold;
	snd_pcm_uframes_t stop_threshold;
	snd_pcm_uframes_t silence_threshold; /* Silence filling happens when
						noise is nearest than this */
	snd_pcm_uframes_t silence_size;	/* Silence filling size */
	snd_pcm_uframes_t boundary;	/* pointers wrap point */

	snd_pcm_uframes_t silenced_start;
	snd_pcm_uframes_t silenced_size;

	snd_pcm_sync_id_t sync;		/* hardware synchronization ID */

	/* -- mmap -- */
	volatile snd_pcm_mmap_status_t *status;
	volatile snd_pcm_mmap_control_t *control;
	atomic_t mmap_count;

	/* -- locking / scheduling -- */
	spinlock_t lock;
	wait_queue_head_t sleep;
	struct timer_list tick_timer;
	struct fasync_struct *fasync;

	/* -- private section -- */
	void *private_data;
	void (*private_free)(snd_pcm_runtime_t *runtime);

	/* -- hardware description -- */
	snd_pcm_hardware_t hw;
	snd_pcm_hw_constraints_t hw_constraints;

	/* -- interrupt callbacks -- */
	void (*transfer_ack_begin)(snd_pcm_substream_t *substream);
	void (*transfer_ack_end)(snd_pcm_substream_t *substream);

	/* -- timer -- */
	unsigned int timer_resolution;	/* timer resolution */

	/* -- DMA -- */           
	unsigned char *dma_area;	/* DMA area */
	dma_addr_t dma_addr;		/* physical bus address (not accessible from main CPU) */
	size_t dma_bytes;		/* size of DMA area */
	void *dma_private;		/* private DMA data for the memory allocator */

#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
	/* -- OSS things -- */
	snd_pcm_oss_runtime_t oss;
#endif
};
]]>
            </programlisting>
          </informalexample>
	</para>

	<para>
	  For the operators (callbacks) of each sound driver, most of
	these records are supposed to be read-only.  Only the PCM
	middle-layer changes / updates these info.  The excpetions are
	the hardware description (hw), interrupt callbacks
	(transfer_ack_xxx), DMA buffer information, and the private
	data.  Besides, if you use the standard buffer allocation
	method via <function>snd_pcm_lib_malloc_pages()</function>,
	you don't need to set the DMA buffer information by yourself.
	</para>

	<para>
	In the sections below, important records are explained.
	</para>

	<section id="pcm-interface-runtime-hw">
	<title>Hardware Description</title>
	<para>
	  The hardware descriptor (<type>snd_pcm_hardware_t</type>)
	contains the definitions of the fundamental hardware
	configuration.  Above all, you'll need to define this in
	<link linkend="pcm-interface-operators-open-callback"><citetitle>
	the open callback</citetitle></link>.
	Note that the runtime instance holds the copy of the
	descriptor, not the pointer to the existing descriptor.  That
	is, in the open callback, you can modify the copied descriptor
	(<constant>runtime-&gt;hw</constant>) as you need.  For example, if the maximum
	number of channels is 1 only on some chip models, you can
	still use the same hardware descriptor and change the
	channels_max later:
          <informalexample>
            <programlisting>
<![CDATA[
          snd_pcm_runtime_t *runtime = substream->runtime;
          ...
          runtime->hw = snd_mychip_playback_hw; // common definition
          if (chip->model == VERY_OLD_ONE)
                  runtime->hw.channels_max = 1;
]]>
            </programlisting>
          </informalexample>
	</para>

	<para>
	  Typically, you'll have a hardware descriptor like below:
          <informalexample>
            <programlisting>
<![CDATA[
  static snd_pcm_hardware_t snd_mychip_playback_hw = {
          .info = (SNDRV_PCM_INFO_MMAP |
                   SNDRV_PCM_INFO_INTERLEAVED |
                   SNDRV_PCM_INFO_BLOCK_TRANSFER |
                   SNDRV_PCM_INFO_MMAP_VALID),
          .formats =          SNDRV_PCM_FMTBIT_S16_LE,
          .rates =            SNDRV_PCM_RATE_8000_48000,
          .rate_min =         8000,
          .rate_max =         48000,
          .channels_min =     2,
          .channels_max =     2,
          .buffer_bytes_max = 32768,
          .period_bytes_min = 4096,
          .period_bytes_max = 32768,
          .periods_min =      1,
          .periods_max =      1024,
  };
]]>
            </programlisting>
          </informalexample>
        </para>

        <para>
	<itemizedlist>
	<listitem><para>
          The <structfield>info</structfield> field contains the type and
        capabilities of this pcm. The bit flags are defined in
        <filename>&lt;sound/asound.h&gt;</filename> as
        <constant>SNDRV_PCM_INFO_XXX</constant>. Here, at least, you
        have to specify whether the mmap is supported and which
        interleaved format is supported.
        When the mmap is supported, add
        <constant>SNDRV_PCM_INFO_MMAP</constant> flag here. When the
        hardware supports the interleaved or the non-interleaved
        format, <constant>SNDRV_PCM_INFO_INTERLEAVED</constant> or
        <constant>SNDRV_PCM_INFO_NONINTERLEAVED</constant> flag must
        be set, respectively. If both are supported, you can set both,
        too. 
        </para>

        <para>
          In the above example, <constant>MMAP_VALID</constant> and
        <constant>BLOCK_TRANSFER</constant> are specified for OSS mmap
        mode. Usually both are set. Of course,
        <constant>MMAP_VALID</constant> is set only if the mmap is
        really supported. 
        </para>

        <para>
          The other possible flags are
        <constant>SNDRV_PCM_INFO_PAUSE</constant> and
        <constant>SNDRV_PCM_INFO_RESUME</constant>. The
        <constant>PAUSE</constant> bit means that the pcm supports the
        <quote>pause</quote> operation, while the
        <constant>RESUME</constant> bit means that the pcm supports
        the <quote>suspend/resume</quote> operation. If these flags
        are set, the <structfield>trigger</structfield> callback below
        must handle the corresponding commands. 
        </para>

	<para>
	  When the PCM substreams can be synchronized (typically,
	synchorinized start/stop of a playback and a capture streams),
	you can give <constant>SNDRV_PCM_INFO_SYNC_START</constant>,
	too.  In this case, you'll need to check the linked-list of
	PCM substreams in the trigger callback.  This will be
	described in the later section.
	</para>
	</listitem>

	<listitem>
        <para>
          <structfield>formats</structfield> field contains the bit-flags
        of supported formats (<constant>SNDRV_PCM_FMTBIT_XXX</constant>).
        If the hardware supports more than one format, give all or'ed
        bits.  In the example above, the signed 16bit little-endian
        format is specified.
        </para>
	</listitem>

	<listitem>
        <para>
        <structfield>rates</structfield> field contains the bit-flags of
        supported rates (<constant>SNDRV_PCM_RATE_XXX</constant>).
        When the chip supports continuous rates, pass
        <constant>CONTINUOUS</constant> bit additionally.
        The pre-defined rate bits are provided only for typical
	rates. If your chip supports unconventional rates, you need to add
        <constant>KNOT</constant> bit and set up the hardware
        constraint manually (explained later).
        </para>
	</listitem>

	<listitem>
	<para>
	<structfield>rate_min</structfield> and
	<structfield>rate_max</structfield> define the minimal and
	maximal sample rate.  This should correspond somehow to
	<structfield>rates</structfield> bits.
	</para>
	</listitem>

	<listitem>
	<para>
	<structfield>channel_min</structfield> and
	<structfield>channel_max</structfield> 
	define, as you might already expected, the minimal and maximal
	number of channels.
	</para>
	</listitem>

	<listitem>
	<para>
	<structfield>buffer_bytes_max</structfield> defines the
	maximal buffer size in bytes.  There is no
	<structfield>buffer_bytes_min</structfield> field, since
	it can be calculated from the minimal period size and the
	minimal number of periods.
	Meanwhile, <structfield>period_bytes_min</structfield> and
	define the minimal and maximal size of the period in bytes.
	<structfield>periods_max</structfield> and
	<structfield>periods_min</structfield> define the maximal and
	minimal number of periods in the buffer.
        </para>

	<para>
	The <quote>period</quote> is a term, that corresponds to
	fragment in the OSS world.  The period defines the size at
	which the PCM interrupt is generated. This size strongly
	depends on the hardware. 
	Generally, the smaller period size will give you more
	interrupts, that is, more controls. 
	In the case of capture, this size defines the input latency.
	On the other hand, the whole buffer size defines the
	output latency for the playback direction.
	</para>
	</listitem>

	<listitem>
	<para>
	There is also a field <structfield>fifo_size</structfield>.
	This specifies the size of the hardware FIFO, but it's not
	used currently in the driver nor in the alsa-lib.  So, you
	can ignore this field.
	</para>
	</listitem>
	</itemizedlist>
	</para>
	</section>

	<section id="pcm-interface-runtime-config">
	<title>PCM Configurations</title>
	<para>
	Ok, let's go back again to the PCM runtime records.
	The most frequently referred records in the runtime instance are
	the PCM configurations.
	The PCM configurations are stored on runtime instance
	after the application sends <type>hw_params</type> data via
	alsa-lib.  There are many fields copied from hw_params and
	sw_params structs.  For example,
	<structfield>format</structfield> holds the format type
	chosen by the application.  This field contains the enum value
	<constant>SNDRV_PCM_FORMAT_XXX</constant>.
	</para>

	<para>
	One thing to be noted is that the configured buffer and period
	sizes are stored in <quote>frames</quote> in the runtime
        In the ALSA world, 1 frame = channels * samples-size.
	For conversion between frames and bytes, you can use the
	helper functions, <function>frames_to_bytes()</function> and
          <function>bytes_to_frames()</function>. 
          <informalexample>
            <programlisting>
<![CDATA[
  period_bytes = frames_to_bytes(runtime, runtime->period_size);
]]>
            </programlisting>
          </informalexample>
        </para>

	<para>
	Also, many software parameters (sw_params) are
	stored in frames, too.  Please check the type of the field.
	<type>snd_pcm_uframes_t</type> is for the frames as unsigned
	integer while <type>snd_pcm_sframes_t</type> is for the frames
	as signed integer.
	</para>
	</section>

	<section id="pcm-interface-runtime-dma">
	<title>DMA Buffer Information</title>
	<para>
	The DMA buffer is defined by the following four fields,
	<structfield>dma_area</structfield>,
	<structfield>dma_addr</structfield>,
	<structfield>dma_bytes</structfield> and
	<structfield>dma_private</structfield>.
	The <structfield>dma_area</structfield> holds the buffer
	pointer (the logical address).  You can call
	<function>memcpy</function> from/to 
	this pointer.  Meanwhile, <structfield>dma_addr</structfield>
	holds the physical address of the buffer.  This field is
	specified only when the buffer is a linear buffer.
	<structfield>dma_bytes</structfield> holds the size of buffer
	in bytes.  <structfield>dma_private</structfield> is used for
	the ALSA DMA allocator.
	</para>

	<para>
	If you use a standard ALSA function,
	<function>snd_pcm_lib_malloc_pages()</function>, for
	allocating the buffer, these fields are set by the ALSA middle
	layer, and you should <emphasis>not</emphasis> change them by
	yourself.  You can read them but not write them.
	On the other hand, if you want to allocate the buffer by
	yourself, you'll need to manage it in hw_params callback.
	At least, <structfield>dma_bytes</structfield> is mandatory.
	<structfield>dma_area</structfield> is necessary when the
	buffer is mmapped.  If your driver doesn't support mmap, this
	field is not necessary.  <structfield>dma_addr</structfield>
	is also not mandatory.  You can use
	<structfield>dma_private</structfield> as you like, too.
	</para>
	</section>

	<section id="pcm-interface-runtime-status">
	<title>Running Status</title>
	<para>
	The running status can be referred via <constant>runtime-&gt;status</constant>.
	This is the pointer to <type>snd_pcm_mmap_status_t</type>
	record.  For example, you can get the current DMA hardware
	pointer via <constant>runtime-&gt;status-&gt;hw_ptr</constant>.
	</para>

	<para>
	The DMA application pointer can be referred via
	<constant>runtime-&gt;control</constant>, which points
	<type>snd_pcm_mmap_control_t</type> record.
	However, accessing directly to this value is not recommended.
	</para>
	</section>

	<section id="pcm-interface-runtime-private">
	<title>Private Data</title> 
	<para>
	You can allocate a record for the substream and store it in
	<constant>runtime-&gt;private_data</constant>.  Usually, this
	done in
	<link linkend="pcm-interface-operators-open-callback"><citetitle>
	the open callback</citetitle></link>.
        Since it's a void pointer, you should use magic-kmalloc and
	magic-cast for such an object. 

          <informalexample>
            <programlisting>
<![CDATA[
  static int snd_xxx_open(snd_pcm_substream_t *substream)
  {
          my_pcm_data_t *data;
          ....
          data = snd_magic_kmalloc(my_pcm_data_t, 0, GFP_KERNEL);
          substream->runtime->private_data = data;
          ....
  }
]]>
            </programlisting>
          </informalexample>
        </para>

        <para>
          The allocated object must be released in
	<link linkend="pcm-interface-operators-open-callback"><citetitle>
	the close callback</citetitle></link>.
        </para>
	</section>

	<section id="pcm-interface-runtime-intr">
	<title>Interrupt Callbacks</title>
	<para>
	The field <structfield>transfer_ack_begin</structfield> and
	<structfield>transfer_ack_end</structfield> are called at
	the beginning and the end of
	<function>snd_pcm_period_elapsed()</function>, respectively. 
	</para>
	</section>

    </section>

    <section id="pcm-interface-operators">
      <title>Operators</title>
      <para>
        OK, now let me explain the detail of each pcm callback
      (<parameter>ops</parameter>). In general, every callback must
      return 0 if successful, or a negative number with the error
      number such as <constant>-EINVAL</constant> at any
      error. 
      </para>

      <para>
        The callback function takes at least the argument with
        <type>snd_pcm_substream_t</type> pointer. For retrieving the
        chip record from the given substream instance, you can use the
        following macro. 

        <informalexample>
          <programlisting>
<![CDATA[
  #define chip_t mychip_t

  int xxx() {
          mychip_t *chip = snd_pcm_substream_chip(substream);
          ....
  }
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        It's expanded with a magic-cast, so the cast-error is
      automatically checked. You should define <type>chip_t</type> at
      the beginning of the code, since this will be referred in many
      places of pcm and control interfaces. 
      </para>

      <section id="pcm-interface-operators-open-callback">
        <title>open callback</title>
        <para>
          <informalexample>
            <programlisting>
<![CDATA[
  static int snd_xxx_open(snd_pcm_substream_t *substream);
]]>
            </programlisting>
          </informalexample>

          This is called when a pcm substream is opened.
        </para>

        <para>
          At least, here you have to initialize the runtime-&gt;hw
          record. Typically, this is done by like this: 

          <informalexample>
            <programlisting>
<![CDATA[
  static int snd_xxx_open(snd_pcm_substream_t *substream)
  {
          mychip_t *chip = snd_pcm_substream_chip(substream);
          snd_pcm_runtime_t *runtime = substream->runtime;

          runtime->hw = snd_mychip_playback_hw;
          return 0;
  }
]]>
            </programlisting>
          </informalexample>

          where <parameter>snd_mychip_playback_hw</parameter> is the
          pre-defined hardware description.
	</para>

	<para>
	You can allocate a private data in this callback, as described
	in <link linkend="pcm-interface-runtime-private"><citetitle>
	Private Data</citetitle></link> section.
	</para>

	<para>
	If the hardware configuration needs more constraints, set the
	hardware constraints here, too.
	See <link linkend="pcm-interface-constraints"><citetitle>
	Constraints</citetitle></link> for more details.
	</para>
      </section>

      <section id="pcm-interface-operators-close-callback">
        <title>close callback</title>
        <para>
          <informalexample>
            <programlisting>
<![CDATA[
  static int snd_xxx_close(snd_pcm_substream_t *substream);
]]>
            </programlisting>
          </informalexample>

          Obviously, this is called when a pcm substream is closed.
        </para>

        <para>
          Any private instance for a pcm substream allocated in the
          open callback will be released here. 

          <informalexample>
            <programlisting>
<![CDATA[
  static int snd_xxx_close(snd_pcm_substream_t *substream)
  {
          ....
          snd_magic_kfree(substream->runtime->private_data);
          ....
  }
]]>
            </programlisting>
          </informalexample>
        </para>
      </section>

      <section id="pcm-interface-operators-ioctl-callback">
        <title>ioctl callback</title>
        <para>
          This is used for any special action to pcm ioctls. But
        usually you can pass a generic ioctl callback, 
        <function>snd_pcm_lib_ioctl</function>.
        </para>
      </section>

      <section id="pcm-interface-operators-hw-params-callback">
        <title>hw_params callback</title>
        <para>
          <informalexample>
            <programlisting>
<![CDATA[
  static int snd_xxx_hw_params(snd_pcm_substream_t * substream,
                               snd_pcm_hw_params_t * hw_params);
]]>
            </programlisting>
          </informalexample>

          This and <structfield>hw_free</structfield> callbacks exist
        only on ALSA 0.9.x. 
        </para>

        <para>
          This is called when the hardware parameter
        (<structfield>hw_params</structfield>) is set
        up by the application, 
        that is, once when the buffer size, the period size, the
        format, etc. are defined for the pcm substream. 
        </para>

        <para>
          Many hardware set-up should be done in this callback,
        including the allocation of buffers. 
        </para>

        <para>
          Parameters to be initialized are retrieved by
          <function>params_xxx()</function> macros. For allocating a
          buffer, you can call a helper function, 

          <informalexample>
            <programlisting>
<![CDATA[
  snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
]]>
            </programlisting>
          </informalexample>

          <function>snd_pcm_lib_malloc_pages()</function> is available
	  only when the DMA buffers have been pre-allocated.
	  See the section <link
	  linkend="buffer-and-memory-buffer-types"><citetitle>
	  Buffer Types</citetitle></link> for more details.
        </para>

        <para>
          Note that this and <structfield>prepare</structfield> callbacks
        may be called multiple times per initialization.
        For example, the OSS emulation may
        call these callbacks at each change via its ioctl. 
        </para>

        <para>
          Thus, you need to take care not to allocate the same buffers
        many times, which will lead to memory leak!  Calling the
        helper function above many times is OK. It will release the
        previous buffer automatically when it was already allocated. 
        </para>

        <para>
          Another note is that this callback is non-atomic
        (schedulable). This is important, because the
        <structfield>prepare</structfield> callback 
        is atomic (non-schedulable). That is, mutex or any
        schedule-related functions are available only in
        <structfield>hw_params</structfield> callback. 
	Please see the subsection
	<link linkend="pcm-interface-atomicity"><citetitle>
	Atomicity</citetitle></link> for details.
        </para>
      </section>

      <section id="pcm-interface-operators-hw-free-callback">
        <title>hw_free callback</title>
        <para>
          <informalexample>
            <programlisting>
<![CDATA[
  static int snd_xxx_hw_free(snd_pcm_substream_t * substream);
]]>
            </programlisting>
          </informalexample>
        </para>

        <para>
          This is called to release the resources allocated via
          <structfield>hw_params</structfield>. For example, releasing the
          buffer via 
          <function>snd_pcm_lib_malloc_pages()</function> is done by
          calling the following: 

          <informalexample>
            <programlisting>
<![CDATA[
  snd_pcm_lib_free_pages(substream);
]]>
            </programlisting>
          </informalexample>
        </para>

        <para>
          This function is always called before the close callback is called.
          Also, the callback may be called multiple times, too.
          Keep track whether the resource was already released. 
        </para>
      </section>

      <section id="pcm-interface-operators-prepare-callback">
       <title>prepare callback</title>
        <para>
          <informalexample>
            <programlisting>
<![CDATA[
  static int snd_xxx_prepare(snd_pcm_substream_t * substream);
]]>
            </programlisting>
          </informalexample>
        </para>

        <para>
          This callback is called when the pcm is
        <quote>prepared</quote>. You can set the format type, sample
        rate, etc. here. The difference from
        <structfield>hw_params</structfield> is that the 
        <structfield>prepare</structfield> callback will be called at each
        time 
        <function>snd_pcm_prepare()</function> is called, i.e. when
        recovered after underruns, etc. 
        </para>

        <para>
          As mentioned above, this callback is atomic.
        </para>

        <para>
          In this and the following callbacks, you can refer to the
        values via the runtime record,
        substream-&gt;runtime.
        For example, to get the current
        rate, format or channels, access to
        runtime-&gt;rate,
        runtime-&gt;format or
        runtime-&gt;channels, respectively. 
        The physical address of the allocated buffer is set to
	runtime-&gt;dma_area.  The buffer and period sizes are
	in runtime-&gt;buffer_size and runtime-&gt;period_size,
	respectively.
        </para>

        <para>
          Be careful that this callback will be called many times at
        each set up, too. 
        </para>
      </section>

      <section id="pcm-interface-operators-trigger-callback">
        <title>trigger callback</title>
        <para>
          <informalexample>
            <programlisting>
<![CDATA[
  static int snd_xxx_trigger(snd_pcm_substream_t * substream, int cmd);
]]>
            </programlisting>
          </informalexample>

          This is called when the pcm is started, stopped or paused.
        </para>

        <para>
          Which action is specified in the second argument,
          <constant>SNDRV_PCM_TRIGGER_XXX</constant> in
          <filename>&lt;sound/pcm.h&gt;</filename>. At least,
          <constant>START</constant> and <constant>STOP</constant>
          commands must be defined in this callback. 

          <informalexample>
            <programlisting>
<![CDATA[
  switch (cmd) {
  case SNDRV_PCM_TRIGGER_START:
          // do something to start the PCM engine
          break;
  case SNDRV_PCM_TRIGGER_STOP:
          // do something to stop the PCM engine
          break;
  default:
          return -EINVAL;
  }
]]>
            </programlisting>
          </informalexample>
        </para>

        <para>
          When the pcm supports the pause operation (given in info
        field of the hardware table), <constant>PAUSE_PUSE</constant>
        and <constant>PAUSE_RELEASE</constant> commands must be
        handled here, too. The former is the command to pause the pcm,
        and the latter to restart the pcm again. 
        </para>

        <para>
          When the pcm supports the suspend/resume operation
        (i.e. <constant>SNDRV_PCM_INFO_RESUME</constant> flag is set),
        <constant>SUSPEND</constant> and <constant>RESUME</constant>
        commands must be handled, too.
        These commands are issued when the power-management status is
        changed.  Obviously, the <constant>SUSPEND</constant> and
        <constant>RESUME</constant>
        do suspend and resume of the pcm substream, and usually, they
        are identical with <constant>STOP</constant> and
        <constant>START</constant> commands, respectively.
        </para>

        <para>
          This callback is also atomic.
        </para>
      </section>

      <section id="pcm-interface-operators-pointer-callback">
        <title>pointer callback</title>
        <para>
          <informalexample>
            <programlisting>
<![CDATA[
  static snd_pcm_uframes_t snd_xxx_pointer(snd_pcm_substream_t * substream)
]]>
            </programlisting>
          </informalexample>

          This callback is called when the PCM middle layer inquires
        the current hardware position on the buffer. The position must
        be returned in frames (which was in bytes on ALSA 0.5.x),
        ranged from 0 to buffer_size - 1.
        </para>

        <para>
          This is called usually from the buffer-update routine in the
        pcm middle layer, which is invoked when
        <function>snd_pcm_period_elapsed()</function> is called in the
        interrupt routine. Then the pcm middle layer updates the
        position and calculates the available space, and wakes up the
        sleeping poll threads, etc. 
        </para>

        <para>
          This callback is also atomic.
        </para>
      </section>

      <section id="pcm-interface-operators-copy-silence">
        <title>copy and silence callbacks</title>
        <para>
          These callbacks are not mandatory, and can be omitted in
        most cases. These callbacks are used when the hardware buffer
        cannot be on the normal memory space. Some chips have their
        own buffer on the hardware which is not mappable. In such a
        case, you have to transfer the data manually from the memory
        buffer to the hardware buffer. Or, if the buffer is
        non-contiguous on both physical and virtual memory spaces,
        these callbacks must be defined, too. 
        </para>

        <para>
          If these two callbacks are defined, copy and set-silence
        operations are done by them. The detailed will be described in
        the later section <link
        linkend="buffer-and-memory"><citetitle>Buffer and Memory
        Management</citetitle></link>. 
        </para>
      </section>

      <section id="pcm-interface-operators-ack">
        <title>ack callback</title>
        <para>
          This callback is also not mandatory. This callback is called
        when the appl_ptr is updated in read or write operations.
        Some drivers like emu10k1-fx and cs46xx need to track the
	current appl_ptr for the internal buffer, and this callback
	is useful only for such a purpose.
	</para>
      </section>

      <section id="pcm-interface-operators-page-callback">
        <title>page callback</title>

        <para>
          This callback is also not mandatory. This callback is used
        mainly for the non-contiguous buffer. The mmap calls this
        callback to get the page address. Some examples will be
        explained in the later section <link
        linkend="buffer-and-memory"><citetitle>Buffer and Memory
        Management</citetitle></link>, too. 
        </para>
      </section>
    </section>

    <section id="pcm-interface-interrupt-handler">
      <title>Interrupt Handler</title>
      <para>
        The rest of pcm stuff is the PCM interrupt handler. The
      role of PCM interrupt handler in the sound driver is to update
      the buffer position and to tell the PCM middle layer when the
      buffer position goes across the prescribed period size. To
      inform this, call <function>snd_pcm_period_elapsed()</function>
      function. 
      </para>

      <para>
        There are several types of sound chips to generate the interrupts.
      </para>

      <section id="pcm-interface-interrupt-handler-boundary">
        <title>Interrupts at the period (fragment) boundary</title>
        <para>
          This is the most frequently found type:  the hardware
        generates an interrupt at each period boundary.
	In this case, you can call
        <function>snd_pcm_period_elapsed()</function> at each 
        interrupt. 
        </para>

        <para>
          <function>snd_pcm_period_elapsed()</function> takes the
        substream pointer as its argument. Thus, you need to keep the
        substream pointer accessible from the chip instance. For
        example, define substream field in the chip record to hold the
        current running substream pointer, and set the pointer value
        at open callback (and reset at close callback). 
        </para>

        <para>
          If you aquire a spinlock in the interrupt handler, and the
        lock is used in other pcm callbacks, too, then you have to
        release the lock before calling
        <function>snd_pcm_period_elapsed()</function>, because
        <function>snd_pcm_period_elapsed()</function> calls other pcm
        callbacks inside. 
        </para>

        <para>
          A typical coding would be like:

          <example>
	    <title>Interrupt Handler Case #1</title>
            <programlisting>
<![CDATA[
  static irqreturn_t snd_mychip_interrupt(int irq, void *dev_id,
                                          struct pt_regs *regs)
  {
          mychip_t *chip = snd_magic_cast(mychip_t, dev_id, return);
          spin_lock(&chip->lock);
          ....
          if (pcm_irq_invoked(chip)) {
                  // call updater, unlock before it
                  spin_unlock(&chip->lock);
                  snd_pcm_period_elapsed(chip->substream);
                  spin_lock(&chip->lock);
                  // acknowledge the interrupt if necessary
          }
          ....
          spin_unlock(&chip->lock);
          return IRQ_HANDLED;
  }
]]>
            </programlisting>
          </example>
        </para>
      </section>

      <section id="pcm-interface-interrupt-handler-timer">
        <title>High-frequent timer interrupts</title>
        <para>
	This is the case when the hardware doesn't generate interrupts
        at the period boundary but do timer-interrupts at the fixed
        timer rate (e.g. es1968 or ymfpci drivers). 
        In this case, you need to check the current hardware
        position and accumulates the processed sample length at each
        interrupt.  When the accumulated size overcomes the period
        size, call 
        <function>snd_pcm_period_elapsed()</function> and reset the
        accumulator. 
        </para>

        <para>
          A typical coding would be like the following.

          <example>
	    <title>Interrupt Handler Case #2</title>
            <programlisting>
<![CDATA[
  static irqreturn_t snd_mychip_interrupt(int irq, void *dev_id,
                                          struct pt_regs *regs)
  {
          mychip_t *chip = snd_magic_cast(mychip_t, dev_id, return);
          spin_lock(&chip->lock);
          ....
          if (pcm_irq_invoked(chip)) {
                  unsigned int last_ptr, size;
                  // get the current hardware pointer (in frames)
                  last_ptr = get_hw_ptr(chip);
                  // calculate the processed frames since the
                  // last update
                  if (last_ptr < chip->last_ptr)
                          size = runtime->buffer_size + last_ptr 
                                   - chip->last_ptr; 
                  else
                          size = last_ptr - chip->last_ptr;
                  // remember the last updated point
                  chip->last_ptr = last_ptr;
                  // accumulate the size
                  chip->size += size;
                  // over the period boundary?
                  if (chip->size >= runtime->period_size) {
                          // reset the accumulator
                          chip->size %= runtime->period_size;
                          // call updater
                          spin_unlock(&chip->lock);
                          snd_pcm_period_elapsed(substream);
                          spin_lock(&chip->lock);
                  }
                  // acknowledge the interrupt if necessary
          }
          ....
          spin_unlock(&chip->lock);
          return IRQ_HANDLED;
  }
]]>
            </programlisting>
          </example>
        </para>
      </section>

      <section id="pcm-interface-interrupt-handler-both">
        <title>On calling <function>snd_pcm_period_elapsed()</function></title>
        <para>
          In both cases, even if more than one period are elapsed, you
        don't have to call
        <function>snd_pcm_period_elapsed()</function> many times. Call
        only once. And the pcm layer will check the current hardware
        pointer and update to the latest status. 
        </para>
      </section>
    </section>

    <section id="pcm-interface-atomicity">
      <title>Atomicity</title>
      <para>
      One of the most important (and thus difficult to debug) problem
      on the kernel programming is the race condition.
      On linux kernel, usually it's solved via spin-locks or
      semaphores.  In general, if the race condition may
      happen in the interrupt handler, it's handled as atomic, and you
      have to use spinlock for protecting the critical session.  If it
      never happens in the interrupt and it may take relatively long
      time, you should use semaphore.
      </para>

      <para>
      As already seen, some pcm callbacks are atomic and some are
      not.  For example, <parameter>hw_params</parameter> callback is
      non-atomic, while <parameter>prepare</parameter> callback is
      atomic.  This means, the latter is called already in a spinlock
      held by the PCM middle layer. Please take this atomicity into
      account when you use a spinlock or a semaphore in the callbacks.
      </para>

      <para>
      In the atomic callbacks, you cannot use functions which may call
      <function>schedule</function> or go to
      <function>sleep</function>.  The semaphore and mutex do sleep,
      and hence they cannot be used inside the atomic callbacks
      (e.g. <parameter>prepare</parameter> callback).
      For taking a certain delay in such a callback, please use
      <function>udelay()</function> or <function>mdelay()</function>.
      </para>

    </section>
    <section id="pcm-interface-constraints">
      <title>Constraints</title>
      <para>
        If your chip supports unconventional sample rates, or only the
      limited samples, you need to set a constraint for the
      condition. 
      </para>

      <para>
        For example, in order to restrict the sample rates in the some
        supported values, use
	<function>snd_pcm_hw_constraint_list()</function>.
	You need to call this function in the open callback.

        <example>
	  <title>Example of Hardware Constraints</title>
          <programlisting>
<![CDATA[
  static unsigned int rates[] =
          {4000, 10000, 22050, 44100};
  static snd_pcm_hw_constraint_list_t constraints_rates = {
          .count = sizeof(rates) / sizeof(rates[0]),
          .list = rates,
          .mask = 0,
  };

  static int snd_mychip_pcm_open(snd_pcm_substream_t *substream)
  {
          int err;
          ....
          err = snd_pcm_hw_constraint_list(substream->runtime, 0,
                                           SNDRV_PCM_HW_PARAM_RATE,
                                           &constraints_rates);
          if (err < 0)
                  return err;
          ....
  }
]]>
          </programlisting>
        </example>
      </para>

      <para>
        There are many different constraints.
        Look in <filename>sound/asound.h</filename> for a complete list.
        You can even define your own constraint rules.
        For example, let's suppose my_chip can manage a substream of 1 channel
        if and only if the format is S16_LE, otherwise it supports any format
        specified in the <type>snd_pcm_hardware_t</type> stucture (or in any
        other constraint_list). You can build a rule like this:

        <example>
	  <title>Example of Hardware Constraints for Channels</title>
	  <programlisting>
<![CDATA[
  static int hw_rule_format_by_channels(snd_pcm_hw_params_t *params,
                                        snd_pcm_hw_rule_t *rule)
  {
          snd_interval_t *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
          snd_mask_t *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);
          snd_mask_t fmt;

          snd_mask_any(&fmt);    // Init the struct
          if (c->min < 2) {
                  fmt.bits[0] &= SNDRV_PCM_FMTBIT_S16_LE;
                  return snd_mask_refine(f, &fmt);
          }
          return 0;
  }
]]>
          </programlisting>
        </example>
      </para>
 
      <para>
        Then you need to call this function to add your rule:

       <informalexample>
	 <programlisting>
<![CDATA[
  snd_pcm_hw_rule_add(substream->runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
                      hw_rule_channels_by_format, 0, SNDRV_PCM_HW_PARAM_FORMAT,
                      -1);
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        The rule function is called when an application sets the number of
        channels. But an application can set the format before the number of
        channels. Thus you also need to define the inverse rule:

       <example>
	 <title>Example of Hardware Constraints for Channels</title>
	 <programlisting>
<![CDATA[
  static int hw_rule_channels_by_format(snd_pcm_hw_params_t *params,
                                        snd_pcm_hw_rule_t *rule)
  {
          snd_interval_t *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
          snd_mask_t *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);
          snd_interval_t ch;

          snd_interval_any(&ch);
          if (f->bits[0] == SNDRV_PCM_FMTBIT_S16_LE) {
                  ch.min = ch.max = 1;
                  ch.integer = 1;
                  return snd_interval_refine(c, &ch);
          }
          return 0;
  }
]]>
          </programlisting>
        </example>
      </para>

      <para>
      ...and in the open callback:
       <informalexample>
	 <programlisting>
<![CDATA[
  snd_pcm_hw_rule_add(substream->runtime, 0, SNDRV_PCM_HW_PARAM_FORMAT,
                      hw_rule_format_by_channels, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
                      -1);
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        I won't explain more details here, rather I
        would like to say, <quote>Luke, use the source.</quote>
      </para>
    </section>

  </chapter>


<!-- ****************************************************** -->
<!-- Control Interface  -->
<!-- ****************************************************** -->
  <chapter id="control-interface">
    <title>Control Interface</title>

    <section id="control-interface-general">
      <title>General</title>
      <para>
        The control interface is used widely for many switches,
      sliders, etc. which are accessed from the user-space. Its most
      important use is the mixer interface. In other words, on ALSA
      0.9.x, all the mixer stuff is implemented on the control kernel
      API (while there was an independent mixer kernel API on 0.5.x). 
      </para>

      <para>
        ALSA has a well-defined AC97 control module. If your chip
      supports only the AC97 and nothing else, you can skip this
      section. 
      </para>

      <para>
        The control API is defined in
      <filename>&lt;sound/control.h&gt;</filename>.
      Include this file if you add your own controls.
      </para>
    </section>

    <section id="control-interface-definition">
      <title>Definition of Controls</title>
      <para>
        For creating a new control, you need to define the three
      callbacks: <structfield>info</structfield>,
      <structfield>get</structfield> and
      <structfield>put</structfield>. Then, define a
      <type>snd_kcontrol_new_t</type> record, such as: 

        <example>
	  <title>Definition of a Control</title>
          <programlisting>
<![CDATA[
  static snd_kcontrol_new_t my_control __devinitdata = {
          .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
          .name = "PCM Playback Switch",
          .index = 0,
          .access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
          .private_values = 0xffff,
          .info = my_control_info,
          .get = my_control_get,
          .put = my_control_put
  };
]]>
          </programlisting>
        </example>
      </para>

      <para>
        Most likely the control is created via
      <function>snd_ctl_new1()</function>, and in such a case, you can
      add <parameter>__devinitdata</parameter> prefix to the
      definition like above. 
      </para>

      <para>
        The <structfield>iface</structfield> field specifies the type of
      the control,
      <constant>SNDRV_CTL_ELEM_IFACE_XXX</constant>. There are
      <constant>MIXER</constant>, <constant>PCM</constant>,
      <constant>CARD</constant>, etc.
      </para>

      <para>
        The <structfield>name</structfield> is the name identifier
      string. On ALSA 0.9.x, the control name is very important,
      because its role is classified from its name. There are
      pre-defined standard control names. The details are described in
      the subsection
      <link linkend="control-interface-control-names"><citetitle>
      Control Names</citetitle></link>.
      </para>

      <para>
        The <structfield>index</structfield> field holds the index number
      of this control. If there are several different controls with
      the same name, they can be distinguished by the index
      number. This is the case when 
      several codecs exist on the card. If the index is zero, you can
      omit the definition above. 
      </para>

      <para>
        The <structfield>access</structfield> field contains the access
      type of this control. Give the combination of bit masks,
      <constant>SNDRV_CTL_ELEM_ACCESS_XXX</constant>, there.
      The detailed will be explained in the subsection
      <link linkend="control-interface-access-flags"><citetitle>
      Access Flags</citetitle></link>.
      </para>

      <para>
        The <structfield>private_values</structfield> field contains
      an arbitrary long integer value for this record. When using
      generic <structfield>info</structfield>,
      <structfield>get</structfield> and
      <structfield>put</structfield> callbacks, you can pass a value 
      through this field. If several small numbers are necessary, you can
      combine them in bitwise. Or, it's possible to give a pointer
      (casted to unsigned long) of some record to this field, too. 
      </para>

      <para>
        The other three are
	<link linkend="control-interface-callbacks"><citetitle>
	callback functions</citetitle></link>.
      </para>
    </section>

    <section id="control-interface-control-names">
      <title>Control Names</title>
      <para>
        There are some standards for defining the control names. A
      control is usually defined from the three parts as
      <quote>SOURCE DIRECTION FUNCTION</quote>. 
      </para>

      <para>
        The first, <constant>SOURCE</constant>, specifies the source
      of the control, and is a string such as <quote>Master</quote>,
      <quote>PCM</quote>, <quote>CD</quote> or
      <quote>Line</quote>. There are many pre-defined sources. 
      </para>

      <para>
        The second, <constant>DIRECTION</constant>, is one of the
      following strings according to the direction of the control:
      <quote>Playback</quote>, <quote>Capture</quote>, <quote>Bypass
      Playback</quote> and <quote>Bypass Capture</quote>. Or, it can
      be omitted, meaning both playback and capture directions. 
      </para>

      <para>
        The third, <constant>FUNCTION</constant>, is one of the
      following strings according to the function of the control:
      <quote>Switch</quote>, <quote>Volume</quote> and
      <quote>Route</quote>. 
      </para>

      <para>
        The example of control names are, thus, <quote>Master Capture
      Switch</quote> or <quote>PCM Playback Volume</quote>. 
      </para>

      <para>
        There are some exceptions:
      </para>

      <section id="control-interface-control-names-global">
        <title>Global capture and playback</title>
        <para>
          <quote>Capture Source</quote>, <quote>Capture Switch</quote>
        and <quote>Capture Volume</quote> are used for the global
        capture (input) source, switch and volume. Similarly,
        <quote>Playback Switch</quote> and <quote>Playback
        Volume</quote> are used for the global output gain switch and
        volume. 
        </para>
      </section>

      <section id="control-interface-control-names-tone">
        <title>Tone-controls</title>
        <para>
          tone-control switch and volumes are specified like
        <quote>Tone Control - XXX</quote>, e.g. <quote>Tone Control -
        Switch</quote>, <quote>Tone Control - Bass</quote>,
        <quote>Tone Control - Center</quote>.  
        </para>
      </section>

      <section id="control-interface-control-names-3d">
        <title>3D controls</title>
        <para>
          3D-control switches and volumes are specified like <quote>3D
        Control - XXX</quote>, e.g. <quote>3D Control -
        Switch</quote>, <quote>3D Control - Center</quote>, <quote>3D
        Control - Space</quote>. 
        </para>
      </section>

      <section id="control-interface-control-names-mic">
        <title>Mic boost</title>
        <para>
          Mic-boost switch is set as <quote>Mic Boost</quote> or
        <quote>Mic Boost (6dB)</quote>. 
        </para>

        <para>
          More precise information can be found in
        <filename>Documentation/sound/alsa/ControlNames.txt</filename>.
        </para>
      </section>
    </section>

    <section id="control-interface-access-flags">
      <title>Access Flags</title>

      <para>
      The access flag is the bit-flags which specifies the access type
      of the given control.  The default access type is
      <constant>SNDRV_CTL_ELEM_ACCESS_READWRITE</constant>, 
      which means both read and write are allowed to this control.
      When the access flag is omitted (i.e. = 0), it is
      regarded as <constant>READWRITE</constant> access as default. 
      </para>

      <para>
      When the control is read-only, pass
      <constant>SNDRV_CTL_ELEM_ACCESS_READ</constant> instead.
      In this case, you don't have to define
      <structfield>put</structfield> callback.
      Similarly, when the control is write-only (although it's a rare
      case), you can use <constant>WRITE</constant> flag instead, and
      you don't need <structfield>get</structfield> callback.
      </para>

      <para>
      If the control value changes frequently (e.g. the VU meter),
      <constant>VOLATILE</constant> flag should be given.  This means
      that the control may be changed without
      <link linkend="control-interface-change-notification"><citetitle>
      notification</citetitle></link>.  Applications should poll such
      a control constantly.
      </para>

      <para>
      When the control is inactive, set
      <constant>INACTIVE</constant> flag, too.
      There are <constant>LOCK</constant> and
      <constant>OWNER</constant> flags for changing the write
      permissions.
      </para>

    </section>

    <section id="control-interface-callbacks">
      <title>Callbacks</title>

      <section id="control-interface-callbacks-info">
        <title>info callback</title>
        <para>
          The <structfield>info</structfield> callback is used to get
        the detailed information of this control. This must store the
        values of the given <type>snd_ctl_elem_info_t</type>
        object. For example, for a boolean control with a single
        element will be: 

          <example>
	    <title>Example of info callback</title>
            <programlisting>
<![CDATA[
  static int snd_myctl_info(snd_kcontrol_t *kcontrol,
                          snd_ctl_elem_info_t *uinfo)
  {
          uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
          uinfo->count = 1;
          uinfo->value.integer.min = 0;
          uinfo->value.integer.max = 1;
          return 0;
  }
]]>
            </programlisting>
          </example>
        </para>

        <para>
          The <structfield>type</structfield> field specifies the type
        of the control. There are <constant>BOOLEAN</constant>,
        <constant>INTEGER</constant>, <constant>ENUMERATED</constant>,
        <constant>BYTES</constant>, <constant>IEC958</constant> and
        <constant>INTEGER64</constant>. The
        <structfield>count</structfield> field specifies the 
        number of elements in this control. For example, a stereo
        volume would have count = 2. The
        <structfield>value</structfield> field is a union, and 
        the values stored are depending on the type. The boolean and
        integer are identical. 
        </para>

        <para>
          The enumerated type is a bit different from others.  You'll
          need to set the string for the currently given item index. 

          <informalexample>
            <programlisting>
<![CDATA[
  static int snd_myctl_info(snd_kcontrol_t *kcontrol,
                          snd_ctl_elem_info_t *uinfo)
  {
          static char *texts[4] = {
                  "First", "Second", "Third", "Fourth"
          };
          uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
          uinfo->count = 1;
          uinfo->value.enumerated.items = 4;
          if (uinfo->value.enumerated.item > 3)
                  uinfo->value.enumerated.item = 3;
          strcpy(uinfo->value.enumerated.name,
                 texts[uinfo->value.enumerated.item]);
          return 0;
  }
]]>
            </programlisting>
          </informalexample>
        </para>
      </section>

      <section id="control-interface-callbacks-get">
        <title>get callback</title>

        <para>
          This callback is used to read the current value of the
        control and to return to the user-space. 
        </para>

        <para>
          For example,

          <example>
	    <title>Example of get callback</title>
            <programlisting>
<![CDATA[
  static int snd_myctl_get(snd_kcontrol_t *kcontrol,
                           snd_ctl_elem_value_t *ucontrol)
  {
          mychip_t *chip = snd_kcontrol_chip(kcontrol);
          ucontrol->value.integer.value[0] = get_some_value(chip);
          return 0;
  }
]]>
            </programlisting>
          </example>
        </para>

        <para>
          Here, the chip instance is retrieved via
        <function>snd_kcontrol_chip()</function> macro.  This macro
        converts from kcontrol-&gt;private_data to the type defined by
        <type>chip_t</type>. The
        kcontrol-&gt;private_data field is 
        given as the argument of <function>snd_ctl_new()</function>
        (see the later subsection
        <link linkend="control-interface-constructor"><citetitle>Constructor</citetitle></link>).
        </para>

        <para>
	The <structfield>value</structfield> field is depending on
        the type of control as well as on info callback.  For example,
	the sb driver uses this field to store the register offset,
        the bit-shift and the bit-mask.  The
        <structfield>private_value</structfield> is set like
          <informalexample>
            <programlisting>
<![CDATA[
  .private_value = reg | (shift << 16) | (mask << 24)
]]>
            </programlisting>
          </informalexample>
	and is retrieved in callbacks like
          <informalexample>
            <programlisting>
<![CDATA[
  static int snd_sbmixer_get_single(snd_kcontrol_t *kcontrol,
                                    snd_ctl_elem_value_t *ucontrol)
  {
          int reg = kcontrol->private_value & 0xff;
          int shift = (kcontrol->private_value >> 16) & 0xff;
          int mask = (kcontrol->private_value >> 24) & 0xff;
          ....
  }
]]>
            </programlisting>
          </informalexample>
	</para>

	<para>
	In <structfield>get</structfield> callback, you have to fill all the elements if the
        control has more than one elements,
        i.e. <structfield>count</structfield> &gt; 1.
	In the example above, we filled only one element
        (<structfield>value.integer.value[0]</structfield>) since it's
        assumed as <structfield>count</structfield> = 1.
        </para>
      </section>

      <section id="control-interface-callbacks-put">
        <title>put callback</title>

        <para>
          This callback is used to write a value from the user-space.
        </para>

        <para>
          For example,

          <example>
	    <title>Example of put callback</title>
            <programlisting>
<![CDATA[
  static int snd_myctl_put(snd_kcontrol_t *kcontrol,
                           snd_ctl_elem_value_t *ucontrol)
  {
          mychip_t *chip = snd_kcontrol_chip(kcontrol);
          int changed = 0;
          if (chip->current_value !=
               ucontrol->value.integer.value[0]) {
                  change_current_value(chip,
                              ucontrol->value.integer.value[0]);
                  changed = 1;
          }
          return changed;
  }
]]>
            </programlisting>
          </example>

          As seen above, you have to return 1 if the value is
        changed. If the value is not changed, return 0 instead. 
	If any fatal error happens, return a negative error code as
        usual.
        </para>

        <para>
	Like <structfield>get</structfield> callback,
	when the control has more than one elements,
	all elemehts must be evaluated in this callback, too.
        </para>
      </section>

      <section id="control-interface-callbacks-all">
        <title>Callbacks are not atomic</title>
        <para>
          All these three callbacks are basically not atomic.
        </para>
      </section>
    </section>

    <section id="control-interface-constructor">
      <title>Constructor</title>
      <para>
        When everything is ready, finally we can create a new
      control. For creating a control, there are two functions to be
      called, <function>snd_ctl_new1()</function> and
      <function>snd_ctl_add()</function>. 
      </para>

      <para>
        In the simplest way, you can do like this:

        <informalexample>
          <programlisting>
<![CDATA[
  if ((err = snd_ctl_add(card, snd_ctl_new1(&my_control, chip))) < 0)
          return err;
]]>
          </programlisting>
        </informalexample>

        where <parameter>my_control</parameter> is the
      <type>snd_kcontrol_new_t</type> object defined above, and chip
      is the object pointer to be passed to
      kcontrol-&gt;private_data 
      which can be referred in callbacks. 
      </para>

      <para>
        <function>snd_ctl_new1()</function> allocates a new
      <type>snd_kcontrol_t</type> instance (that's why the definition
      of <parameter>my_control</parameter> can be with
      <parameter>__devinitdata</parameter> 
      prefix), and <function>snd_ctl_add</function> assigns the given
      control component to the card. 
      </para>
    </section>

    <section id="control-interface-change-notification">
      <title>Change Notification</title>
      <para>
        If you need to change and update a control in the interrupt
      routine, you can call <function>snd_ctl_notify()</function>. For
      example, 

        <informalexample>
          <programlisting>
<![CDATA[
  snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, id_pointer);
]]>
          </programlisting>
        </informalexample>

        This function takes the card pointer, the event-mask, and the
      control id pointer for the notification. The event-mask
      specifies the types of notification, for example, in the above
      example, the change of control values is notified.
      The id pointer is the pointer of <type>snd_ctl_elem_id_t</type>
      to be notified.
      You can find some examples in <filename>es1938.c</filename> or
      <filename>es1968.c</filename> for hardware volume interrupts. 
      </para>
    </section>

  </chapter>


<!-- ****************************************************** -->
<!-- API for AC97 Codec  -->
<!-- ****************************************************** -->
  <chapter id="api-ac97">
    <title>API for AC97 Codec</title>

    <section>
      <title>General</title>
      <para>
        The ALSA AC97 codec layer is a well-defined one, and you don't
      have to write many codes to control it. Only low-level control
      routines are necessary. The AC97 codec API is defined in
      <filename>&lt;sound/ac97_codec.h&gt;</filename>. 
      </para>
    </section>

    <section id="api-ac97-example">
      <title>Full Code Example</title>
      <para>
          <example>
	    <title>Example of AC97 Interface</title>
            <programlisting>
<![CDATA[
  struct snd_mychip {
          ....
          ac97_t *ac97;
          ....
  };

  static unsigned short snd_mychip_ac97_read(ac97_t *ac97,
                                             unsigned short reg)
  {
          mychip_t *chip = snd_magic_cast(mychip_t,
                                   ac97->private_data, return 0);
          ....
          // read a register value here from the codec
          return the_register_value;
  }

  static void snd_mychip_ac97_write(ac97_t *ac97,
                                   unsigned short reg, unsigned short val)
  {
          mychip_t *chip = snd_magic_cast(mychip_t,
                                   ac97->private_data, return 0);
          ....
          // write the given register value to the codec
  }

  static int snd_mychip_ac97(mychip_t *chip)
  {
          ac97_bus_t bus, *pbus;
          ac97_t ac97;
          int err;

          memset(&bus, 0, sizeof(bus));
          bus.write = snd_mychip_ac97_write;
          bus.read = snd_mychip_ac97_read;
          if ((err = snd_ac97_bus(chip->card, &bus, &pbus)) < 0)
                  return err;
          memset(&ac97, 0, sizeof(ac97));
          ac97.private_data = chip;
          return snd_ac97_mixer(pbus, &ac97, &chip->ac97);
  }

]]>
          </programlisting>
        </example>
      </para>
    </section>

    <section id="api-ac97-constructor">
      <title>Constructor</title>
      <para>
        For creating an ac97 instance, first call <function>snd_ac97_bus</function>
      with <type>ac97_bus_t</type> record including callback functions.

        <informalexample>
          <programlisting>
<![CDATA[
  ac97_bus_t bus, *pbus;
  int err;

  memset(&bus, 0, sizeof(bus));
  bus.write = snd_mychip_ac97_write;
  bus.read = snd_mychip_ac97_read;
  snd_ac97_bus(card, &bus, &pbus);
]]>
          </programlisting>
        </informalexample>

      The bus record is shared among all belonging ac97 instances.
      </para>

      <para>
      And then call <function>snd_ac97_mixer()</function> with an <type>ac97_t</type>
      record together with the bus pointer created above.

        <informalexample>
          <programlisting>
<![CDATA[
  ac97_t ac97;
  int err;

  memset(&ac97, 0, sizeof(ac97));
  ac97.private_data = chip;
  snd_ac97_mixer(bus, &ac97, &chip->ac97);
]]>
          </programlisting>
        </informalexample>

        where chip-&gt;ac97 is the pointer of a newly created
        <type>ac97_t</type> instance.
        In this case, the chip pointer is set as the private data, so that
        the read/write callback functions can refer to this chip instance.
        This instance is not necessarily stored in the chip
	record.  When you need to change the register values from the
        driver, or need the suspend/resume of ac97 codecs, keep this
        pointer to pass to the corresponding functions.
      </para>
    </section>

    <section id="api-ac97-callbacks">
      <title>Callbacks</title>
      <para>
        The standard callbacks are <structfield>read</structfield> and
      <structfield>write</structfield>. Obviously they 
      correspond to the functions for read and write accesses to the
      hardware low-level codes. 
      </para>

      <para>
        The <structfield>read</structfield> callback returns the
        register value specified in the argument. 

        <informalexample>
          <programlisting>
<![CDATA[
  static unsigned short snd_mychip_ac97_read(ac97_t *ac97,
                                             unsigned short reg)
  {
          mychip_t *chip = snd_magic_cast(mychip_t,
                                   ac97->private_data, return 0);
          ....
          return the_register_value;
  }
]]>
          </programlisting>
        </informalexample>

        Here, the chip can be cast from ac97-&gt;private_data.
      </para>

      <para>
        Meanwhile, the <structfield>write</structfield> callback is
        used to set the register value. 

        <informalexample>
          <programlisting>
<![CDATA[
  static void snd_mychip_ac97_write(ac97_t *ac97,
                       unsigned short reg, unsigned short val)
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
      These callbacks are non-atomic like the callbacks of control API.
      </para>

      <para>
        There are also other callbacks:
      <structfield>reset</structfield>,
      <structfield>wait</structfield> and
      <structfield>init</structfield>. 
      </para>

      <para>
        The <structfield>reset</structfield> callback is used to reset
      the codec. If the chip requires a special way of reset, you can
      define this callback. 
      </para>

      <para>
        The <structfield>wait</structfield> callback is used for a
      certain wait at the standard initialization of the codec. If the
      chip requires the extra wait-time, define this callback. 
      </para>

      <para>
        The <structfield>init</structfield> callback is used for
      additional initialization of the codec.
      </para>
    </section>

    <section id="api-ac97-updating-registers">
      <title>Updating Registers in The Driver</title>
      <para>
        If you need to access to the codec from the driver, you can
      call the following functions:
      <function>snd_ac97_write()</function>,
      <function>snd_ac97_read()</function>,
      <function>snd_ac97_update()</function> and
      <function>snd_ac97_update_bits()</function>. 
      </para>

      <para>
        Both <function>snd_ac97_write()</function> and
        <function>snd_ac97_update()</function> functions are used to
        set a value to the given register
        (<constant>AC97_XXX</constant>). The different between them is
        that <function>snd_ac97_update()</function> doesn't write a
        value if the given value has been already set, while
        <function>snd_ac97_write()</function> always rewrites the
        value. 

        <informalexample>
          <programlisting>
<![CDATA[
  snd_ac97_write(ac97, AC97_MASTER, 0x8080);
  snd_ac97_update(ac97, AC97_MASTER, 0x8080);
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        <function>snd_ac97_read()</function> is used to read the value
        of the given register. For example, 

        <informalexample>
          <programlisting>
<![CDATA[
  value = snd_ac97_read(ac97, AC97_MASTER);
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        <function>snd_ac97_update_bits()</function> is used to update
        some bits of the given register.  

        <informalexample>
          <programlisting>
<![CDATA[
  snd_ac97_update_bits(ac97, reg, mask, value);
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        Also, there is a function to change the sample rate (of a
        certain register such as
        <constant>AC97_PCM_FRONT_DAC_RATE</constant>) when VRA is
        supported by the codec:
        <function>snd_ac97_set_rate()</function>. 

        <informalexample>
          <programlisting>
<![CDATA[
  snd_ac97_set_rate(ac97, AC97_PCM_FRONT_DAC_RATE, 44100);
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        The following registers are available for setting the rate:
      <constant>AC97_PCM_MIC_ADC_RATE</constant>,
      <constant>AC97_PCM_FRONT_DAC_RATE</constant>,
      <constant>AC97_PCM_LR_ADC_RATE</constant>,
      <constant>AC97_SPDIF</constant>. When the
      <constant>AC97_SPDIF</constant> is specified, the register is
      not really changed but the corresponding IEC958 status bits will
      be updated. 
      </para>
    </section>

    <section id="api-ac97-clock-adjustment">
      <title>Clock Adjustment</title>
      <para>
        On some chip, the clock of the codec isn't 48000 but using a
      PCI clock (to save a quartz!). In this case, change the field
      ac97-&gt;clock to the corresponding
      value. For example, intel8x0 
      and es1968 drivers have the auto-measurement function of the
      clock. 
      </para>
    </section>

    <section id="api-ac97-proc-files">
      <title>Proc Files</title>
      <para>
        The ALSA AC97 interface will create a proc file such as
      <filename>/proc/asound/card0/ac97#0</filename> and
      <filename>ac97#0regs</filename>. You can refer to these files to
      see the current status and registers of the codec. 
      </para>
    </section>

    <section id="api-ac97-multiple-codecs">
      <title>Multiple Codecs</title>
      <para>
        When there are several codecs on the same card, you need to
      call <function>snd_ac97_new()</function> multiple times with
      ac97.num=1 or greater. The <structfield>num</structfield> field
      specifies the codec 
      number. 
      </para>

      <para>
        If you have set up multiple codecs, you need to either write
      different callbacks for each codec or check
      ac97-&gt;num in the 
      callback routines. 
      </para>
    </section>

  </chapter>


<!-- ****************************************************** -->
<!-- MIDI (MPU401-UART) Interface  -->
<!-- ****************************************************** -->
  <chapter id="midi-interface">
    <title>MIDI (MPU401-UART) Interface</title>

    <section id="midi-interface-general">
      <title>General</title>
      <para>
        Many soundcards have built-in MIDI (MPU401-UART)
      interfaces. When the soundcard supports the standard MPU401-UART
      interface, most likely you can use the ALSA MPU401-UART API. The
      MPU401-UART API is defined in
      <filename>&lt;sound/mpu401.h&gt;</filename>. 
      </para>

      <para>
        Some soundchips have similar but a little bit different
      implementation of mpu401 stuff. For example, emu10k1 has its own
      mpu401 routines. 
      </para>

      <para>
        In this document, I won't explain the rawmidi interface API,
      which is the basis of MPU401-UART implementation. 
      </para>

      <para>
        For details, please check the source,
      <filename>core/rawmidi.c</filename>, and examples such as
      <filename>drivers/mpu401/mpu401_uart.c</filename> or
      <filename>usb/usbmidi.c</filename>. 
      </para>
    </section>

    <section id="midi-interface-constructor">
      <title>Constructor</title>
      <para>
        For creating a rawmidi object, call
      <function>snd_mpu401_uart_new()</function>. 

        <informalexample>
          <programlisting>
<![CDATA[
  snd_rawmidi_t *rmidi;
  snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401, port, integrated,
                      irq, irq_flags, &rmidi);
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        The first argument is the card pointer, and the second is the
      index of this component. You can create up to 8 rawmidi
      devices. 
      </para>

      <para>
        The third argument is the type of the hardware,
      <constant>MPU401_HW_XXX</constant>. If it's not a special one,
      you can use <constant>MPU401_HW_MPU401</constant>. 
      </para>

      <para>
        The 4th argument is the i/o port address. Many
      backward-compatible MPU401 has an i/o port such as 0x330. Or, it
      might be a part of its own PCI i/o region. It depends on the
      chip design. 
      </para>

      <para>
        When the i/o port address above is a part of the PCI i/o
      region, the MPU401 i/o port might have been already allocated
      (reserved) by the driver itself. In such a case, pass non-zero
      to the 5th argument
      (<parameter>integrated</parameter>). Otherwise, pass 0 to it,
      and 
      the mpu401-uart layer will allocate the i/o ports by itself. 
      </para>

      <para>
        Usually, the port address corresponds to the command port and
        port + 1 corresponds to the data port. If not, you may change
        the <structfield>cport</structfield> field of
        <type>mpu401_t</type> manually 
        afterward. However, <type>mpu401_t</type> pointer is not
        returned explicitly by
        <function>snd_mpu401_uart_new()</function>. You need to cast
        rmidi-&gt;private_data to
        <type>mpu401_t</type> explicitly, 

        <informalexample>
          <programlisting>
<![CDATA[
  mpu401_t *mpu;
  mpu = snd_magic_cast(mpu401_t, rmidi->private_data, );
]]>
          </programlisting>
        </informalexample>

        and reset the cport as you like:

        <informalexample>
          <programlisting>
<![CDATA[
  mpu->cport = my_own_control_port;
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        The 6th argument specifies the irq number for UART. If the irq
      is already allocated, pass 0 to the 7th argument
      (<parameter>irq_flags</parameter>). Otherwise, pass the flags
      for irq allocation 
      (<constant>SA_XXX</constant> bits) to it, and the irq will be
      reserved by the mpu401-uart layer. If the card doesn't generates
      UART interrupts, pass -1 as the irq number. Then a timer
      interrupt will be invoked for polling. 
      </para>
    </section>

    <section id="midi-interface-interrupt-handler">
      <title>Interrupt Handler</title>
      <para>
        When the interrupt is allocated in
      <function>snd_mpu401_uart_new()</function>, the private
      interrupt handler is used, hence you don't have to do nothing
      else than creating the mpu401 stuff. Otherwise, you have to call
      <function>snd_mpu401_uart_interrupt()</function> explicitly when
      a UART interrupt is invoked and checked in your own interrupt
      handler.  
      </para>

      <para>
        In this case, you need to pass the private_data of the
        returned rawmidi object from
        <function>snd_mpu401_uart_new()</function> as the second
        argument of <function>snd_mpu401_uart_interrupt()</function>. 

        <informalexample>
          <programlisting>
<![CDATA[
  snd_mpu401_uart_interrupt(irq, rmidi->private_data, regs);
]]>
          </programlisting>
        </informalexample>
      </para>
    </section>

  </chapter>


<!-- ****************************************************** -->
<!-- Miscellaneous Devices  -->
<!-- ****************************************************** -->
  <chapter id="misc-devices">
    <title>Miscellaneous Devices</title>

    <section id="misc-devices-opl3">
      <title>FM OPL3</title>
      <para>
        The FM OPL3 is still used on many chips (mainly for backward
      compatibility). ALSA has a nice OPL3 FM control layer, too. The
      OPL3 API is defined in
      <filename>&lt;sound/opl3.h&gt;</filename>. 
      </para>

      <para>
        FM registers can be directly accessed through direct-FM API,
      defined in <filename>&lt;sound/asound_fm.h&gt;</filename>. In
      ALSA native mode, FM registers are accessed through
      Hardware-Dependant Device direct-FM extension API, whereas in
      OSS compatible mode, FM registers can be accessed with OSS
      direct-FM compatible API on <filename>/dev/dmfmX</filename> device. 
      </para>

      <para>
        For creating the OPL3 component, you have two functions to
        call. The first one is a constructor for <type>opl3_t</type>
        instance. 

        <informalexample>
          <programlisting>
<![CDATA[
  opl3_t *opl3;
  snd_opl3_create(card, lport, rport, OPL3_HW_OPL3_XXX,
                  integrated, &opl3);
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        The first argument is the card pointer, the second one is the
      left port address, and the third is the right port address. In
      most cases, the right port is placed at the left port + 2. 
      </para>

      <para>
        The fourth argument is the hardware type.
      </para>

      <para>
        When the left and right ports have been already allocated by
      the card driver, pass non-zero to the fifth argument
      (<parameter>integrated</parameter>). Otherwise, opl3 module will
      allocate the specified ports by itself. 
      </para>

      <para>
        If this function returns successfully with 0, then create a
        hwdep device for this opl3. 

        <informalexample>
          <programlisting>
<![CDATA[
  snd_hwdep_t *opl3hwdep;
  snd_opl3_hwdep_new(opl3, 0, 1, &opl3hwdep);
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        The first argument is the <type>opl3_t</type> instance you
      created, and the second is the index number, usually 0. 
      </para>

      <para>
        The third argument is the index-offset for the sequencer
      client assigned to the OPL3 port. When there is an MPU401-UART,
      give 1 for here (UART always takes 0). 
      </para>
    </section>

    <section id="misc-devices-hardware-dependent">
      <title>Hardware-Dependent Devices</title>
      <para>
        Some chips need the access from the user-space for special
      controls or for loading the micro code. In such a case, you can
      create a hwdep (hardware-dependent) device. The hwdep API is
      defined in <filename>&lt;sound/hwdep.h&gt;</filename>. You can
      find examples in opl3 driver or
      <filename>isa/sb/sb16_csp.c</filename>. 
      </para>

      <para>
        Creation of the <type>hwdep</type> instance is done via
        <function>snd_hwdep_new()</function>. 

        <informalexample>
          <programlisting>
<![CDATA[
  snd_hwdep_t *hw;
  snd_hwdep_new(card, "My HWDEP", 0, &hw);
]]>
          </programlisting>
        </informalexample>

        where the third argument is the index number.
      </para>

      <para>
        You can then pass any pointer value to the
        <parameter>private_data</parameter>. Again, it should be a
        magic-allocated record, so that the cast can be checked more
        safely. If you assign a private data, you should define the
        destructor, too. The destructor function is set to
        <structfield>private_free</structfield> field.  

        <informalexample>
          <programlisting>
<![CDATA[
  mydata_t *p = snd_magic_kmalloc(mydata_t, 0, GFP_KERNEL);
  hw->private_data = p;
  hw->private_free = mydata_free;
]]>
          </programlisting>
        </informalexample>

        and the implementation of destructor would be:

        <informalexample>
          <programlisting>
<![CDATA[
  static void mydata_free(snd_hwdep_t *hw)
  {
          mydata_t *p = snd_magic_cast(mydata_csp_t,
                                       hw->private_data, return);
          snd_magic_kfree(p);
  }
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        The arbitrary file operations can be defined for this
        instance. The file operators are defined in
        <parameter>ops</parameter> table. For example, assume that
        this chip needs an ioctl. 

        <informalexample>
          <programlisting>
<![CDATA[
  hw->ops.open = mydata_open;
  hw->ops.ioctl = mydata_ioctl;
  hw->ops.release = mydata_release;
]]>
          </programlisting>
        </informalexample>

        And implement the callback functions as you like.
      </para>
    </section>

    <section id="misc-devices-IEC958">
      <title>IEC958 (S/PDIF)</title>
      <para>
        Usually the controls for IEC958 devices are implemented via
      control interface. There is a macro to compose a name string for
      IEC958 controls, <function>SNDRV_CTL_NAME_IEC958()</function>
      defined in <filename>&lt;include/asound.h&gt;</filename>.  
      </para>

      <para>
        There are some standard controls for IEC958 status bits. These
      controls use the type <type>SNDRV_CTL_ELEM_TYPE_IEC958</type>,
      and the size of element is fixed as 4 bytes array
      (value.iec958.status[x]). For <structfield>info</structfield>
      callback, you don't specify 
      the value field for this type (the count field must be set,
      though). 
      </para>

      <para>
        <quote>IEC958 Playback Con Mask</quote> is used to return the
      bit-mask for the IEC958 status bits of consumer mode. Similarly,
      <quote>IEC958 Playback Pro Mask</quote> returns the bitmask for
      professional mode. They are read-only controls, and are defined
      as MIXER controls (iface =
      <constant>SNDRV_CTL_ELEM_IFACE_MIXER</constant>).  
      </para>

      <para>
        Meanwhile, <quote>IEC958 Playback Default</quote> control is
      defined for getting and setting the current default IEC958
      bits. Note that this one is usually defined as a PCM control
      (iface = <constant>SNDRV_CTL_ELEM_IFACE_PCM</constant>),
      although in some places it's defined as a MIXER control. 
      </para>

      <para>
        In addition, you can define the control switches to
      enable/disable or to set the raw bit mode. The implementation
      will depend on the chip, but the control should be named as
      <quote>IEC958 xxx</quote>, preferably using
      <function>SNDRV_CTL_NAME_IEC958()</function> macro. 
      </para>

      <para>
        You can find several cases, for example,
      <filename>pci/emu10k1</filename>,
      <filename>pci/ice1712</filename>, or
      <filename>pci/cmipci.c</filename>.  
      </para>
    </section>

  </chapter>


<!-- ****************************************************** -->
<!-- Buffer and Memory Management  -->
<!-- ****************************************************** -->
  <chapter id="buffer-and-memory">
    <title>Buffer and Memory Management</title>

    <section id="buffer-and-memory-buffer-types">
      <title>Buffer Types</title>
      <para>
        ALSA provides several different buffer allocation functions
      depending on the bus and the architecture. All these have a
      consistent API. The allocation of physically-contiguous pages is
      done via 
      <function>snd_malloc_xxx_pages()</function> function, where xxx
      is the bus type. 
      </para>

      <para>
        The allocation of pages with fallback is
      <function>snd_malloc_xxx_pages_fallback()</function>. This
      function tries to allocate the specified pages but if the pages
      are not available, it tries to reduce the page sizes until the
      enough space is found.
      </para>

      <para>
      For releasing the space, call
      <function>snd_free_xxx_pages()</function> function. 
      </para>

      <para>
      Usually, ALSA drivers try to allocate and reserve
       a large contiguous physical space
       at the time the module is loaded for the later use.
       This is called <quote>pre-allocation</quote>.
       As already written, you can call the following function at the
       construction of pcm instance (in the case of PCI bus). 

        <informalexample>
          <programlisting>
<![CDATA[
  snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
                                        snd_dma_pci_data(pci), size, max);
]]>
          </programlisting>
        </informalexample>

        where <parameter>size</parameter> is the byte size to be
      pre-allocated and the <parameter>max</parameter> is the maximal
      size to be changed via <filename>prealloc</filename> proc file.
      The allocator will try to get as the large area as possible
      within the given size. 
      </para>

      <para>
      The second argument (type) and the third argument (device pointer)
      are dependent on the bus.
      In the case of ISA bus, pass <function>snd_dma_isa_data()</function>
      as the third argument with <constant>SNDRV_DMA_TYPE_DEV</constant> type.
      For the continuous buffer unrelated to the bus can be pre-allocated
      with <constant>SNDRV_DMA_TYPE_CONTINUOUS</constant> type and the
      <function>snd_dma_continuous_data(GFP_KERNEL)</function> device pointer,
      whereh <constant>GFP_KERNEL</constant> is the kernel allocation flag to
      use.  For the SBUS, <constant>SNDRV_DMA_TYPE_SBUS</constant> and
      <function>snd_dma_sbus_data(sbus_dev)</function> are used instead.
      For the PCI scatter-gather buffers, use
      <constant>SNDRV_DMA_TYPE_DEV_SG</constant> with
      <function>snd_dma_pci_data(pci)</function>
      (see the section
          <link linkend="buffer-and-memory-non-contiguous"><citetitle>Non-Contiguous Buffers
          </citetitle></link>).
      </para>

      <para>
        Once when the buffer is pre-allocated, you can use the
        allocator in the <structfield>hw_params</structfield> callback 

        <informalexample>
          <programlisting>
<![CDATA[
  snd_pcm_lib_malloc_pages(substream, size);
]]>
          </programlisting>
        </informalexample>

        Note that you have to pre-allocate to use this function.
      </para>
    </section>

    <section id="buffer-and-memory-external-hardware">
      <title>External Hardware Buffers</title>
      <para>
        Some chips have their own hardware buffers and the DMA
      transfer from the host memory is not available. In such a case,
      you need to either 1) copy/set the audio data directly to the
      external hardware buffer, or 2) make an intermediate buffer and
      copy/set the data from it to the external hardware buffer in
      interrupts (or in tasklets, preferably).
      </para>

      <para>
        The first case works fine if the external hardware buffer is enough
      large.  This method doesn't need any extra buffers and thus is
      more effective. You need to define the
      <structfield>copy</structfield> and
      <structfield>silence</structfield> callbacks for 
      the data transfer. However, there is a drawback: it cannot
      be mmapped. The examples are GUS's GF1 PCM or emu8000's
      wavetable PCM. 
      </para>

      <para>
        The second case allows the mmap of the buffer, although you have
      to handle an interrupt or a tasklet for transferring the data
      from the intermediate buffer to the hardware buffer. You can find an
      example in vxpocket driver. 
      </para>

      <para>
        Another case is that the chip uses a PCI memory-map
      region for the buffer instead of the host memory. In this case,
      mmap is available only on certain architectures like intel. In
      non-mmap mode, the data cannot be transferred as the normal
      way. Thus you need to define <structfield>copy</structfield> and
      <structfield>silence</structfield> callbacks as well 
      as in the cases above. The examples are found in
      <filename>rme32.c</filename> and <filename>rme96.c</filename>. 
      </para>

      <para>
        The implementation of <structfield>copy</structfield> and
        <structfield>silence</structfield> callbacks depends upon 
        whether the hardware supports interleaved or non-interleaved
        samples. The <structfield>copy</structfield> callback is
        defined like below, a bit 
        differently depending whether the direction is playback or
        capture: 

        <informalexample>
          <programlisting>
<![CDATA[
  static int playback_copy(snd_pcm_substream_t *substream, int channel,
               snd_pcm_uframes_t pos, void *src, snd_pcm_uframes_t count);
  static int capture_copy(snd_pcm_substream_t *substream, int channel,
               snd_pcm_uframes_t pos, void *dst, snd_pcm_uframes_t count);
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        In the case of interleaved samples, the second argument
      (<parameter>channel</parameter>) is not used. The third argument
      (<parameter>pos</parameter>) points the 
      current position offset in frames. 
      </para>

      <para>
        The meaning of the fourth argument is different between
      playback and capture. For playback, it holds the source data
      pointer, and for capture, it's the destination data pointer. 
      </para>

      <para>
        The last argument is the number of frames to be copied.
      </para>

      <para>
        What you have to do in this callback is again different
        between playback and capture directions. In the case of
        playback, you do: copy the given amount of data
        (<parameter>count</parameter>) at the specified pointer
        (<parameter>src</parameter>) to the specified offset
        (<parameter>pos</parameter>) on the hardware buffer. When
        coded like memcpy-like way, the copy would be like: 

        <informalexample>
          <programlisting>
<![CDATA[
  my_memcpy(my_buffer + frames_to_bytes(runtime, pos), src,
            frames_to_bytes(runtime, count));
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        For the capture direction, you do: copy the given amount of
        data (<parameter>count</parameter>) at the specified offset
        (<parameter>pos</parameter>) on the hardware buffer to the
        specified pointer (<parameter>dst</parameter>). 

        <informalexample>
          <programlisting>
<![CDATA[
  my_memcpy(dst, my_buffer + frames_to_bytes(runtime, pos),
            frames_to_bytes(runtime, count));
]]>
          </programlisting>
        </informalexample>

        Note that both of the position and the data amount are given
      in frames. 
      </para>

      <para>
        In the case of non-interleaved samples, the implementation
      will be a bit more complicated. 
      </para>

      <para>
        You need to check the channel argument, and if it's -1, copy
      the whole channels. Otherwise, you have to copy only the
      specified channel. Please check
      <filename>isa/gus/gus_pcm.c</filename> as an example. 
      </para>

      <para>
        The <structfield>silence</structfield> callback is also
        implemented in a similar way. 

        <informalexample>
          <programlisting>
<![CDATA[
  static int silence(snd_pcm_substream_t *substream, int channel,
                     snd_pcm_uframes_t pos, snd_pcm_uframes_t count);
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        The meanings of arguments are identical with the
      <structfield>copy</structfield> 
      callback, although there is no <parameter>src/dst</parameter>
      argument. In the case of interleaved samples, the channel
      argument has no meaning, as well as on
      <structfield>copy</structfield> callback.  
      </para>

      <para>
        The role of <structfield>silence</structfield> callback is to
        set the given amount 
        (<parameter>count</parameter>) of silence data at the
        specified offset (<parameter>pos</parameter>) on the hardware
        buffer. Suppose that the data format is signed (that is, the
        silent-data is 0), and the implementation using a memset-like
        function would be like: 

        <informalexample>
          <programlisting>
<![CDATA[
  my_memcpy(my_buffer + frames_to_bytes(runtime, pos), 0,
            frames_to_bytes(runtime, count));
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        In the case of non-interleaved samples, again, the
      implementation becomes a bit more complicated. See, for example,
      <filename>isa/gus/gus_pcm.c</filename>. 
      </para>
    </section>

    <section id="buffer-and-memory-non-contiguous">
      <title>Non-Contiguous Buffers</title>
      <para>
        If your hardware supports the page table like emu10k1 or the
      buffer descriptors like via82xx, you can use the scatter-gather
      (SG) DMA. ALSA provides an interface for handling SG-buffers.
      The API is provided in <filename>&lt;sound/pcm_sgbuf.h&gt;</filename>. 
      </para>

      <para>
        For creating the SG-buffer handler, call
        <function>snd_pcm_lib_preallocate_pages()</function> or
        <function>snd_pcm_lib_preallocate_pages_for_all()</function>
        with <constant>SNDRV_DMA_TYPE_DEV_SG</constant>
	in the PCM constructor like other PCI pre-allocator.
        You need to pass the <function>snd_dma_pci_data(pci)</function>,
        where pci is the struct <structname>pci_dev</structname> pointer
        of the chip as well.
        The <type>snd_sg_buf_t</type> instance is created as
        substream-&gt;dma_private. You can cast
        the pointer like: 

        <informalexample>
          <programlisting>
<![CDATA[
  snd_pcm_sgbuf_t *sgbuf = (snd_pcm_sgbuf_t*)substream->dma_private;
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        Then call <function>snd_pcm_lib_malloc_pages()</function>
      in <structfield>hw_params</structfield> callback
      as well as in the case of normal PCI buffer.
      The SG-buffer handler will allocate the non-contiguous kernel
      pages of the given size and map them onto the virtually contiguous
      memory.  The virtual pointer is addressed in runtime-&gt;dma_area.
      The physical address (runtime-&gt;dma_addr) is set to zero,
      because the buffer is physically non-contigous.
      The physical address table is set up in sgbuf-&gt;table.
      You can get the physical address at a certain offset via
      <function>snd_pcm_sgbuf_get_addr()</function>. 
      </para>

      <para>
        When a SG-handler is used, you need to set
      <function>snd_pcm_sgbuf_ops_page</function> as
      the <structfield>page</structfield> callback.
      (See <link linkend="pcm-interface-operators-page-callback">
      <citetitle>page callback section</citetitle></link>.)
      </para>

      <para>
        For releasing the data, call
      <function>snd_pcm_lib_free_pages()</function> in the
      <structfield>hw_free</structfield> callback as usual.
      </para>
    </section>

    <section id="buffer-and-memory-vmalloced">
      <title>Vmalloc'ed Buffers</title>
      <para>
        It's possible to use a buffer allocated via
      <function>vmalloc</function>, for example, for an intermediate
      buffer. Since the allocated pages are not contiguous, you need
      to set the <structfield>page</structfield> callback to obtain
      the physical address at every offset. 
      </para>

      <para>
        The implementation of <structfield>page</structfield> callback
        would be like this: 

        <informalexample>
          <programlisting>
<![CDATA[
  #include <linux/vmalloc.h>

  /* get the physical page pointer on the given offset */
  static struct page *mychip_page(snd_pcm_substream_t *substream,
                                  unsigned long offset)
  {
          void *pageptr = substream->runtime->dma_area + offset;
          return vmalloc_to_page(pageptr);
  }
]]>
          </programlisting>
        </informalexample>
      </para>
    </section>

  </chapter>


<!-- ****************************************************** -->
<!-- Proc Interface  -->
<!-- ****************************************************** -->
  <chapter id="proc-interface">
    <title>Proc Interface</title>
    <para>
      ALSA provides an easy interface for procfs. The proc files are
      very useful for debugging. I recommend you set up proc files if
      you write a driver and want to get a running status or register
      dumps. The API is found in
      <filename>&lt;sound/info.h&gt;</filename>. 
    </para>

    <para>
      For creating a proc file, call
      <function>snd_card_proc_new()</function>. 

      <informalexample>
        <programlisting>
<![CDATA[
  snd_info_entry_t *entry;
  int err = snd_card_proc_new(card, "my-file", &entry);
]]>
        </programlisting>
      </informalexample>

      where the second argument specifies the proc-file name to be
    created. The above example will create a file
    <filename>my-file</filename> under the card directory,
    e.g. <filename>/proc/asound/card0/my-file</filename>. 
    </para>

    <para>
    Like other components, the proc entry created via
    <function>snd_card_proc_new()</function> will be registered and
    released automatically in the card registration and release
    functions.
    </para>

    <para>
      When the creation is successful, the function stores a new
    instance at the pointer given in the third argument.
    It is initialized as a text proc file for read only.  For using
    this proc file as a read-only text file as it is, set the read
    callback with a private data via 
     <function>snd_info_set_text_ops()</function>.

      <informalexample>
        <programlisting>
<![CDATA[
  snd_info_set_text_ops(entry, chip, read_size, my_proc_read);
]]>
        </programlisting>
      </informalexample>
    
    where the second argument (<parameter>chip</parameter>) is the
    private data to be used in the callbacks. The third parameter
    specifies the read buffer size and the fourth
    (<parameter>my_proc_read</parameter>) is the callback function, which
    is defined like

      <informalexample>
        <programlisting>
<![CDATA[
  static void my_proc_read(snd_info_entry_t *entry,
                           snd_info_buffer_t *buffer);
]]>
        </programlisting>
      </informalexample>
    
    </para>

    <para>
    In the read callback, use <function>snd_iprintf()</function> for
    output strings, which works just like normal
    <function>printf()</function>.  For example,

      <informalexample>
        <programlisting>
<![CDATA[
  static void my_proc_read(snd_info_entry_t *entry,
                           snd_info_buffer_t *buffer)
  {
          chip_t *cm = snd_magic_cast(mychip_t,
                                  entry->private_data, return);

          snd_iprintf(buffer, "This is my chip!\n");
          snd_iprintf(buffer, "Port = %ld\n", chip->port);
  }
]]>
        </programlisting>
      </informalexample>
    </para>

    <para>
    The file permission can be changed afterwards.  As default, it's
    set as read only for all users.  If you want to add the write
    permission to the user (root as default), set like below:

      <informalexample>
        <programlisting>
<![CDATA[
 entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
]]>
        </programlisting>
      </informalexample>

    and set the write buffer size and the callback

      <informalexample>
        <programlisting>
<![CDATA[
  entry->c.text.write_size = 256;
  entry->c.text.write = my_proc_write;
]]>
        </programlisting>
      </informalexample>
    </para>

    <para>
    The buffer size for read is set to 1024 implicitly by
    <function>snd_info_set_text_ops()</function>.  It should suffice
    in most cases (the size will be aligned to
    <constant>PAGE_SIZE</constant> anyway), but if you need to handle
    very large text files, you can set it explicitly, too.

      <informalexample>
        <programlisting>
<![CDATA[
  entry->c.text.read_size = 65536;
]]>
        </programlisting>
      </informalexample>
    </para>

    <para>
      For the write callback, you can use
    <function>snd_info_get_line()</function> to get a text line, and
    <function>snd_info_get_str()</function> to retrieve a string from
    the line. Some examples are found in
    <filename>core/oss/mixer_oss.c</filename>, core/oss/and
    <filename>pcm_oss.c</filename>. 
    </para>

    <para>
      For a raw-data proc-file, set the attributes like the following:

      <informalexample>
        <programlisting>
<![CDATA[
  static struct snd_info_entry_ops my_file_io_ops = {
          .read = my_file_io_read,
  };

  entry->content = SNDRV_INFO_CONTENT_DATA;
  entry->private_data = chip;
  entry->c.ops = &my_file_io_ops;
  entry->size = 4096;
  entry->mode = S_IFREG | S_IRUGO;
]]>
        </programlisting>
      </informalexample>
    </para>

    <para>
      The callback is much more complicated than the text-file
      version. You need to use a low-level i/o functions such as
      <function>copy_from/to_user()</function> to transfer the
      data.

      <informalexample>
        <programlisting>
<![CDATA[
  static long my_file_io_read(snd_info_entry_t *entry,
                              void *file_private_data,
                              struct file *file,
                              char *buf,
                              unsigned long count,
                              unsigned long pos)
  {
          long size = count;
          if (pos + size > local_max_size)
                  size = local_max_size - pos;
          if (copy_to_user(buf, local_data + pos, size))
                  return -EFAULT;
          return size;
  }
]]>
        </programlisting>
      </informalexample>
    </para>

  </chapter>


<!-- ****************************************************** -->
<!-- Power Management  -->
<!-- ****************************************************** -->
  <chapter id="power-management">
    <title>Power Management</title>
    <para>
      If the chip is supposed to work with with suspend/resume
      functions, you need to add the power-management codes to the
      driver. The additional codes for the power-management should be
      <function>ifdef</function>'ed with
      <constant>CONFIG_PM</constant>. 
    </para>

    <para>
      ALSA provides the common power-management layer. Each card driver
      needs to have only low-level suspend and resume callbacks.

      <informalexample>
        <programlisting>
<![CDATA[
  #ifdef CONFIG_PM
  static int snd_my_suspend(snd_card_t *card, unsigned int state)
  {
          .... // do things for suspsend
          return 0;
  }
  static int snd_my_resume(snd_card_t *card, unsigned int state)
  {
          .... // do things for suspsend
          return 0;
  }
  #endif
]]>
        </programlisting>
      </informalexample>
    </para>

    <para>
      The scheme of the real suspend job is as following.

      <orderedlist>
        <listitem><para>Retrieve the chip data from pm_private_data field.</para></listitem>
        <listitem><para>Call <function>snd_pcm_suspend_all()</function> to suspend the running PCM streams.</para></listitem>
        <listitem><para>Save the register values if necessary.</para></listitem>
        <listitem><para>Stop the hardware if necessary.</para></listitem>
        <listitem><para>Set the power-state as D3hot by calling <function>snd_power_change_state()</function>.</para></listitem>
      </orderedlist>
    </para>

    <para>
      A typical code would be like:

      <informalexample>
        <programlisting>
<![CDATA[
  static int mychip_suspend(snd_card_t *card, unsigned int state)
  {
          // (1)
          mychip_t *chip = snd_magic_cast(mychip_t, card->pm_private_data,
                                          return -ENXIO);
          // (2)
          snd_pcm_suspend_all(chip->pcm);
          // (3)
          snd_mychip_save_registers(chip);
          // (4)
          snd_mychip_stop_hardware(chip);
          // (5)
          snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
          return 0;
  }
]]>
        </programlisting>
      </informalexample>
    </para>

    <para>
    The scheme of the real resume job is as following.

    <orderedlist>
    <listitem><para>Retrieve the chip data from pm_private_data field.</para></listitem>
    <listitem><para>Enable the pci device again by calling
    <function>pci_enable_device()</function>.</para></listitem>
    <listitem><para>Re-initialize the chip.</para></listitem>
    <listitem><para>Restore the saved registers if necessary.</para></listitem>
    <listitem><para>Resume the mixer, e.g. calling
    <function>snd_ac97_resume()</function>.</para></listitem>
    <listitem><para>Restart the hardware (if any).</para></listitem>
    <listitem><para>Set the power-state as D0 by calling
    <function>snd_power_change_state()</function>.</para></listitem>
    </orderedlist>
    </para>

    <para>
    A typical code would be like:

      <informalexample>
        <programlisting>
<![CDATA[
  static void mychip_resume(mychip_t *chip)
  {
          // (1)
          mychip_t *chip = snd_magic_cast(mychip_t, card->pm_private_data,
                                          return -ENXIO);
          // (2)
          pci_enable_device(chip->pci);
          // (3)
          snd_mychip_reinit_chip(chip);
          // (4)
          snd_mychip_restore_registers(chip);
          // (5)
          snd_ac97_resume(chip->ac97);
          // (6)
          snd_mychip_restart_chip(chip);
          // (7)
          snd_power_change_state(card, SNDRV_CTL_POWER_D0);
          return 0;
  }
]]>
        </programlisting>
      </informalexample>
    </para>

    <para>
      OK, we have all callbacks now. Let's set up them now. In the
      initialization of the card, add the following: 

      <informalexample>
        <programlisting>
<![CDATA[
  static int __devinit snd_mychip_probe(struct pci_dev *pci,
                               const struct pci_device_id *pci_id)
  {
          ....
          snd_card_t *card;
          mychip_t *chip;
          ....
          snd_card_set_pm_callback(card, snd_my_suspend, snd_my_resume, chip);
          ....
  }
]]>
        </programlisting>
      </informalexample>

    Here you don't have to put ifdef CONFIG_PM around, since it's already
    checked in the header and expanded to empty if not needed.
    </para>

    <para>
      If you need a space for saving the registers, you'll need to
    allocate the buffer for it here, too, since it would be fatal
    if you cannot allocate a memory in the suspend phase.
    The allocated buffer should be released in the corresponding
    destructor.
    </para>

    <para>
      And next, set suspend/resume callbacks to the pci_driver,
      This can be done by passing a macro SND_PCI_PM_CALLBACKS
      in the pci_driver struct.  This macro is expanded to the correct
      (global) callbacks if CONFIG_PM is set.

      <informalexample>
        <programlisting>
<![CDATA[
  static struct pci_driver driver = {
          .name = "My Chip",
          .id_table = snd_my_ids,
          .probe = snd_my_probe,
          .remove = __devexit_p(snd_my_remove),
          SND_PCI_PM_CALLBACKS
  };
]]>
        </programlisting>
      </informalexample>
    </para>

  </chapter>


<!-- ****************************************************** -->
<!-- Module Parameters  -->
<!-- ****************************************************** -->
  <chapter id="module-parameters">
    <title>Module Parameters</title>
    <para>
      There are standard module options for ALSA. At least, each
      module should have <parameter>index</parameter>,
      <parameter>id</parameter> and <parameter>enable</parameter>
      options. 
    </para>

    <para>
      If the module supports multiple cards (usually up to
      8 = <constant>SNDRV_CARDS</constant> cards), they should be
      arrays.  The default initial values are defined already as
      constants for ease of programming:

      <informalexample>
        <programlisting>
<![CDATA[
  static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
  static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
  static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
]]>
        </programlisting>
      </informalexample>
    </para>

    <para>
      If the module supports only a single card, they could be single
    variables, instead.  <parameter>enable</parameter> option is not
    always necessary in this case, but it wouldn't be so bad to have a
    dummy option for compatibility.
    </para>

    <para>
      The module parameters must be declared with the standard
    <function>module_param()()</function>,
    <function>module_param_array()()</function> and
    <function>MODULE_PARM_DESC()</function> macros. The ALSA provides
    an additional macro, <function>MODULE_PARM_SYNTAX()</function>,
    for describing its syntax. The strings will be written to
    <filename>/lib/modules/XXX/modules.generic_string</filename>
    file. 
    </para>

    <para>
      For convenience, the typical string arguments given to
    <function>MODULE_PARM_SYNTAX()</function> are defined in
    <filename>&lt;sound/initval.h&gt;</filename>, such as
    <constant>SNDRV_ID_DESC</constant> or
    <constant>SNDRV_ENABLED</constant>.
    </para>

    <para>
      The typical coding would be like below:

      <informalexample>
        <programlisting>
<![CDATA[
  #define CARD_NAME "My Chip"

  static int boot_devs;
  module_param_array(index, int, boot_devs, 0444);
  MODULE_PARM_DESC(index, "Index value for " CARD_NAME " soundcard.");
  MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
  module_param_array(id, charp, boot_devs, 0444);
  MODULE_PARM_DESC(id, "ID string for " CARD_NAME " soundcard.");
  MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
  module_param_array(enable, bool, boot_devs, 0444);
  MODULE_PARM_DESC(enable, "Enable " CARD_NAME " soundcard.");
  MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
]]>
        </programlisting>
      </informalexample>

    Here boot_devs is passed but simply ignored since we don't care
    the number of parsed parameters.
    </para>

    <para>
      Also, don't forget to define the module description, classes,
      license and devices. Especially, the recent modprobe requires to
      define the module license as GPL, etc., otherwise the system is
      shown as <quote>tainted</quote>. 

      <informalexample>
        <programlisting>
<![CDATA[
  MODULE_DESCRIPTION("My Chip");
  MODULE_CLASSES("{sound}");
  MODULE_LICENSE("GPL");
  MODULE_DEVICES("{{Vendor,My Chip Name}}");
]]>
        </programlisting>
      </informalexample>
    </para>

  </chapter>


<!-- ****************************************************** -->
<!-- How To Put Your Driver  -->
<!-- ****************************************************** -->
  <chapter id="how-to-put-your-driver">
    <title>How To Put Your Driver Into ALSA Tree</title>
	<section>
	<title>General</title>
	<para>
	So far, you've learned how to write the driver codes.
	And you might have a question now: how to put my own
	driver into the ALSA driver tree?
	Here (finally :) the standard procedure is described briefly.
	</para>

	<para>
	Suppose that you'll create a new PCI driver for the card
	<quote>xyz</quote>.  The card module name would be
	snd-xyz.  The new driver is usually put into alsa-driver
	tree, <filename>alsa-driver/pci</filename> directory in
	the case of PCI cards.
	Then the driver is evaluated, audited and tested
	by developers and users.  After a certain time, the driver
	will go to alsa-kernel tree (to the corresponding directory,
	such as <filename>alsa-kernel/pci</filename>) and eventually
	integrated into Linux 2.6 tree (the directory would be
	<filename>linux/sound/pci</filename>).
	</para>

	<para>
	In the following sections, the driver code is supposed
	to be put into alsa-driver tree.  The two cases are assumed:
	a driver consisting of a single source file and one consisting
	of several source files.
	</para>
	</section>

	<section>
	<title>Driver with A Single Source File</title>
	<para>
	<orderedlist>
	<listitem>
	<para>
	Modify alsa-driver/pci/Makefile
	</para>

	<para>
	Suppose you have a file xyz.c.  Add the following
	two lines
      <informalexample>
        <programlisting>
<![CDATA[
  snd-xyz-objs := xyz.o
  obj-$(CONFIG_SND_XYZ) += snd-xyz.o
]]>
        </programlisting>
      </informalexample>
	</para>
	</listitem>

	<listitem>
	<para>
	Create the Kconfig entry
	</para>

	<para>
	Add the new entry of Kconfig for your xyz driver.
      <informalexample>
        <programlisting>
<![CDATA[
  config SND_XYZ
          tristate "Foobar XYZ"
          depends on SND
          select SND_PCM
          help
            Say 'Y' or 'M' to include support for Foobar XYZ soundcard.
]]>
        </programlisting>
      </informalexample>

	the line, select SND_PCM, specifies that the driver xyz supports
	PCM.  In addition to SND_PCM, the following components are
	supported for select command:
	SND_RAWMIDI, SND_TIMER, SND_HWDEP, SND_MPU401_UART,
	SND_OPL3_LIB, SND_OPL4_LIB, SND_VX_LIB, SND_AC97_CODEC.
	Add the select command for each supported component.
	</para>

	<para>
	Note that some selections imply the lowlevel selections.
	For example, PCM includes TIMER, MPU401_UART includes RAWMIDI,
	AC97_CODEC includes PCM, and OPL3_LIB includes HWDEP.
	You don't need to give the lowlevel selections again.
	</para>

	<para>
	For the details of Kconfig script, refer to the kbuild
	documentation.
	</para>

	</listitem>

	<listitem>
	<para>
	Run cvscompile script to re-generate the configure script and
	build the whole stuff again.
	</para>
	</listitem>
	</orderedlist>
	</para>
	</section>

	<section>
	<title>Drivers with Several Source Files</title>
	<para>
	Suppose that the driver snd-xyz have several source files.
	They are located in the new subdirectory,
	pci/xyz.

	<orderedlist>
	<listitem>
	<para>
	Add a new directory (<filename>xyz</filename>) in
	<filename>alsa-driver/pci/Makefile</filename> like below

      <informalexample>
        <programlisting>
<![CDATA[
  obj-$(CONFIG_SND) += xyz/
]]>
        </programlisting>
      </informalexample>
	</para>
	</listitem>

	<listitem>
	<para>
	Under the directory <filename>xyz</filename>, create a Makefile

      <example>
	<title>Sample Makefile for a driver xyz</title>
        <programlisting>
<![CDATA[
  ifndef SND_TOPDIR
  SND_TOPDIR=../..
  endif

  include $(TOPDIR)/toplevel.config
  include $(TOPDIR)/Makefile.conf

  snd-xyz-objs := xyz.o abc.o def.o

  obj-$(CONFIG_SND_XYZ) += snd-xyz.o

  include $(TOPDIR)/Rules.make
]]>
        </programlisting>
      </example>
	</para>
	</listitem>

	<listitem>
	<para>
	Create the Kconfig entry
	</para>

	<para>
	This procedure is as same as in the last section.
	</para>
	</listitem>

	<listitem>
	<para>
	Run cvscompile script to re-generate the configure script and
	build the whole stuff again.
	</para>
	</listitem>
	</orderedlist>
	</para>
	</section>

  </chapter>

<!-- ****************************************************** -->
<!-- Useful Functions  -->
<!-- ****************************************************** -->
  <chapter id="useful-functions">
    <title>Useful Functions</title>

    <section id="useful-functions-snd-printk">
      <title><function>snd_printk()</function> and friends</title>
      <para>
        ALSA provides a verbose version of
      <function>printk()</function> function. If a kernel config
      <constant>CONFIG_SND_VERBOSE_PRINTK</constant> is set, this
      function prints the given message together with the file name
      and the line of the caller. The <constant>KERN_XXX</constant>
      prefix is processed as 
      well as the original <function>printk()</function> does, so it's
      recommended to add this prefix, e.g. 

        <informalexample>
          <programlisting>
<![CDATA[
  snd_printk(KERN_ERR "Oh my, sorry, it's extremely bad!\n");
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        There are also <function>printk()</function>'s for
      debugging. <function>snd_printd()</function> can be used for
      general debugging purposes. If
      <constant>CONFIG_SND_DEBUG</constant> is set, this function is
      compiled, and works just like
      <function>snd_printk()</function>. If the ALSA is compiled
      without the debugging flag, it's ignored. 
      </para>

      <para>
        <function>snd_printdd()</function> is compiled in only when
      <constant>CONFIG_SND_DEBUG_DETECT</constant> is set. Please note
      that <constant>DEBUG_DETECT</constant> is not set as default
      even if you configure the alsa-driver with
      <option>--with-debug=full</option> option. You need to give
      explicitly <option>--with-debug=detect</option> option instead. 
      </para>
    </section>

    <section id="useful-functions-snd-assert">
      <title><function>snd_assert()</function></title>
      <para>
        <function>snd_assert()</function> macro is similar with the
      normal <function>assert()</function> macro. For example,  

        <informalexample>
          <programlisting>
<![CDATA[
  snd_assert(pointer != NULL, return -EINVAL);
]]>
          </programlisting>
        </informalexample>
      </para>

      <para>
        The first argument is the expression to evaluate, and the
      second argument is the action if it fails. When
      <constant>CONFIG_SND_DEBUG</constant>, is set, it will show an
      error message such as <computeroutput>BUG? (xxx) (called from
      yyy)</computeroutput>. When no debug flag is set, this is
      ignored. 
      </para>
    </section>

    <section id="useful-functions-snd-runtime-check">
      <title><function>snd_runtime_check()</function></title>
      <para>
        This macro is quite similar with
      <function>snd_assert()</function>. Unlike
      <function>snd_assert()</function>, the expression is always
      evaluated regardless of
      <constant>CONFIG_SND_DEBUG</constant>. When
      <constant>CONFIG_SND_DEBUG</constant> is set, the macro will
      show a message like <computeroutput>ERROR (xx) (called from
      yyy)</computeroutput>. 
      </para>
    </section>

    <section id="useful-functions-snd-bug">
      <title><function>snd_BUG()</function></title>
      <para>
        It calls <function>snd_assert(0,)</function> -- that is, just
      prints the error message at the point. It's useful to show that
      a fatal error happens there. 
      </para>
    </section>
  </chapter>


<!-- ****************************************************** -->
<!-- Acknowledgments  -->
<!-- ****************************************************** -->
  <chapter id="acknowledments">
    <title>Acknowledgments</title>
    <para>
      I would like to thank Phil Kerr for his help for improvement and
      corrections of this document. 
    </para>
    <para>
    Kevin Conder reformatted the original plain-text to the
    DocBook format.
    </para>
    <para>
    Giuliano Pochini corrected typos and contributed the example codes
    in the hardware constraints section.
    </para>
  </chapter>


</book>
