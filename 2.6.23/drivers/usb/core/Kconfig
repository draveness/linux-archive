#
# USB Core configuration
#
config USB_DEBUG
	bool "USB verbose debug messages"
	depends on USB
	help
	  Say Y here if you want the USB core & hub drivers to produce a bunch
	  of debug messages to the system log. Select this if you are having a
	  problem with USB support and want to see more of what is going on.

comment "Miscellaneous USB options"
	depends on USB

config USB_DEVICEFS
	bool "USB device filesystem"
	depends on USB
	---help---
	  If you say Y here (and to "/proc file system support" in the "File
	  systems" section, above), you will get a file /proc/bus/usb/devices
	  which lists the devices currently connected to your USB bus or
	  busses, and for every connected device a file named
	  "/proc/bus/usb/xxx/yyy", where xxx is the bus number and yyy the
	  device number; the latter files can be used by user space programs
	  to talk directly to the device. These files are "virtual", meaning
	  they are generated on the fly and not stored on the hard drive.

	  You may need to mount the usbfs file system to see the files, use
	  mount -t usbfs none /proc/bus/usb

	  For the format of the various /proc/bus/usb/ files, please read
	  <file:Documentation/usb/proc_usb_info.txt>.

	  Usbfs files can't handle Access Control Lists (ACL), which are the
	  default way to grant access to USB devices for untrusted users of a
	  desktop system. The usbfs functionality is replaced by real
	  device-nodes managed by udev. These nodes live in /dev/bus/usb and
	  are used by libusb.

config USB_DEVICE_CLASS
	bool "USB device class-devices (DEPRECATED)"
	depends on USB
	default y
	---help---
	  Userspace access to USB devices is granted by device-nodes exported
	  directly from the usbdev in sysfs. Old versions of the driver
	  core and udev needed additional class devices to export device nodes.

	  These additional devices are difficult to handle in userspace, if
	  information about USB interfaces must be available. One device
	  contains the device node, the other device contains the interface
	  data. Both devices are at the same level in sysfs (siblings) and one
	  can't access the other. The device node created directly by the
	  usb device is the parent device of the interface and therefore
	  easily accessible from the interface event.

	  This option provides backward compatibility for libusb device
	  nodes (lsusb) when usbfs is not used, and the following udev rule
	  doesn't exist:
	    SUBSYSTEM=="usb", ACTION=="add", ENV{DEVTYPE}=="usb_device", \
	    NAME="bus/usb/$env{BUSNUM}/$env{DEVNUM}", MODE="0644"

config USB_DYNAMIC_MINORS
	bool "Dynamic USB minor allocation (EXPERIMENTAL)"
	depends on USB && EXPERIMENTAL
	help
	  If you say Y here, the USB subsystem will use dynamic minor
	  allocation for any device that uses the USB major number.
	  This means that you can have more than 16 of a single type
	  of device (like USB printers).

	  If you are unsure about this, say N here.

config USB_SUSPEND
	bool "USB selective suspend/resume and wakeup (EXPERIMENTAL)"
	depends on USB && PM && EXPERIMENTAL
	help
	  If you say Y here, you can use driver calls or the sysfs
	  "power/state" file to suspend or resume individual USB
	  peripherals.

	  Also, USB "remote wakeup" signaling is supported, whereby some
	  USB devices (like keyboards and network adapters) can wake up
	  their parent hub.  That wakeup cascades up the USB tree, and
	  could wake the system from states like suspend-to-RAM.

	  If you are unsure about this, say N here.

config USB_PERSIST
	bool "USB device persistence during system suspend (DANGEROUS)"
	depends on USB && PM && EXPERIMENTAL
	default n
	help

	  If you say Y here and enable the "power/persist" attribute
	  for a USB device, the device's data structures will remain
	  persistent across system suspend, even if the USB bus loses
	  power.  (This includes hibernation, also known as swsusp or
	  suspend-to-disk.)  The devices will reappear as if by magic
	  when the system wakes up, with no need to unmount USB
	  filesystems, rmmod host-controller drivers, or do anything
	  else.

	  	WARNING: This option can be dangerous!

	  If a USB device is replaced by another of the same type while
	  the system is asleep, there's a good chance the kernel won't
	  detect the change.  Likewise if the media in a USB storage
	  device is replaced.  When this happens it's almost certain to
	  cause data corruption and maybe even crash your system.

	  If you are unsure, say N here.

config USB_OTG
	bool
	depends on USB && EXPERIMENTAL
	select USB_SUSPEND
	default n


config USB_OTG_WHITELIST
	bool "Rely on OTG Targeted Peripherals List"
	depends on USB_OTG
	default y
	help
	  If you say Y here, the "otg_whitelist.h" file will be used as a
	  product whitelist, so USB peripherals not listed there will be
	  rejected during enumeration.  This behavior is required by the
	  USB OTG specification for all devices not on your product's
	  "Targeted Peripherals List".

	  Otherwise, peripherals not listed there will only generate a
	  warning and enumeration will continue.  That's more like what
	  normal Linux-USB hosts do (other than the warning), and is
	  convenient for many stages of product development.

config USB_OTG_BLACKLIST_HUB
	bool "Disable external hubs"
	depends on USB_OTG
	help
	  If you say Y here, then Linux will refuse to enumerate
	  external hubs.  OTG hosts are allowed to reduce hardware
	  and software costs by not supporting external hubs.

